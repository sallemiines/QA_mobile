'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersJs = require('../helpers.js');

var _teen_process = require('teen_process');

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _asyncbox = require('asyncbox');

var _appiumSupport = require('appium-support');

var apkUtilsMethods = {};

/**
 * Check whether the particular package is present on the device under test.
 *
 * @param {string} pkg - The name of the package to check.
 * @return {boolean} True if the package is installed.
 */
apkUtilsMethods.isAppInstalled = function callee$0$0(pkg) {
  var installed, stdout, apkInstalledRgx;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        installed = false;

        _loggerJs2['default'].debug('Getting install status for ' + pkg);
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'list', 'packages', pkg]));

      case 5:
        stdout = context$1$0.sent;
        apkInstalledRgx = new RegExp('^package:' + pkg.replace(/(\.)/g, "\\$1") + '$', 'm');

        installed = apkInstalledRgx.test(stdout);
        _loggerJs2['default'].debug('App is' + (!installed ? ' not' : '') + ' installed');
        return context$1$0.abrupt('return', installed);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error finding if app is installed. Original error: ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 12]]);
};

/**
 * Start the particular URI on the device under test.
 *
 * @param {string} uri - The name of URI to start.
 * @param {string} pkg - The name of the package to start the URI with.
 */
apkUtilsMethods.startUri = function callee$0$0(uri, pkg) {
  var args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!uri || !pkg) {
          _loggerJs2['default'].errorAndThrow("URI and package arguments are required");
        }
        context$1$0.prev = 1;
        args = ["am", "start", "-W", "-a", "android.intent.action.VIEW", "-d", uri, pkg];
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        _loggerJs2['default'].errorAndThrow('Error attempting to start URI. Original error: ' + context$1$0.t0);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
};

/**
 * Start the particular package on the device under test.
 *
 * @param {object} startAppOptions [{}] - Startup options mapping.
 *                                        It is mandatory that 'activity' and 'pkg' properties are set.
 *                                        Additional supported properties are: 'retry', 'stopApp', 'waitPkg'
 *                                        and 'waitActivity'.
 * @return {string} The output of the corresponding adb command.
 */
apkUtilsMethods.startApp = function callee$0$0() {
  var startAppOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var apiLevel, cmd, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        if (!startAppOptions.activity || !startAppOptions.pkg) {
          _loggerJs2['default'].errorAndThrow("activity and pkg is required for launching application");
        }
        startAppOptions = _lodash2['default'].clone(startAppOptions);
        startAppOptions.activity = startAppOptions.activity.replace('$', '\\$');

        // initializing defaults
        _lodash2['default'].defaults(startAppOptions, {
          waitPkg: startAppOptions.pkg,
          waitActivity: false,
          retry: true,
          stopApp: true
        });
        // preventing null waitpkg
        startAppOptions.waitPkg = startAppOptions.waitPkg || startAppOptions.pkg;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getApiLevel());

      case 8:
        apiLevel = context$1$0.sent;
        cmd = (0, _helpersJs.buildStartCmd)(startAppOptions, apiLevel);
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.shell(cmd));

      case 12:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf("Error: Activity class") !== -1 && stdout.indexOf("does not exist") !== -1)) {
          context$1$0.next = 24;
          break;
        }

        if (!(startAppOptions.retry && startAppOptions.activity[0] !== ".")) {
          context$1$0.next = 21;
          break;
        }

        _loggerJs2['default'].debug("We tried to start an activity that doesn't exist, " + "retrying with . prepended to activity");
        startAppOptions.activity = '.' + startAppOptions.activity;
        startAppOptions.retry = false;
        return context$1$0.abrupt('return', this.startApp(startAppOptions));

      case 21:
        _loggerJs2['default'].errorAndThrow("Activity used to start app doesn't exist or cannot be " + "launched! Make sure it exists and is a launchable activity");

      case 22:
        context$1$0.next = 25;
        break;

      case 24:
        if (stdout.indexOf("java.lang.SecurityException") !== -1) {
          // if the app is disabled on a real device it will throw a security exception
          _loggerJs2['default'].errorAndThrow("Permission to start activity denied.");
        }

      case 25:
        if (!startAppOptions.waitActivity) {
          context$1$0.next = 28;
          break;
        }

        context$1$0.next = 28;
        return _regeneratorRuntime.awrap(this.waitForActivity(startAppOptions.waitPkg, startAppOptions.waitActivity, startAppOptions.waitDuration));

      case 28:
        context$1$0.next = 33;
        break;

      case 30:
        context$1$0.prev = 30;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].errorAndThrow('Error occured while starting App. Original error: ' + context$1$0.t0.message);

      case 33:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 30]]);
};

/**
 * @typedef {Object} PackageActivityInfo
 * @property {?string} appPackage - The name of application package,
 *                                  for example 'com.acme.app'.
 * @property {?string} appActivity - The name of main application activity.
 */

/**
 * Get the name of currently focused package and activity.
 *
 * @return {PackageActivityInfo} The mapping, where property names are 'appPackage' and 'appActivity'.
 * @throws {Error} If there is an error while parsing the data.
 */
apkUtilsMethods.getFocusedPackageAndActivity = function callee$0$0() {
  var cmd, nullRe, searchRe, stdout, foundNullMatch, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, foundMatch;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting focused package and activity");
        cmd = ['dumpsys', 'window', 'windows'];
        nullRe = new RegExp(/mFocusedApp=null/);
        searchRe = new RegExp('mFocusedApp.+Record\\{.*\\s([^\\s\\/\\}]+)' + '\\/([^\\s\\/\\}\\,]+)\\,?(\\s[^\\s\\/\\}]+)*\\}');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.shell(cmd));

      case 7:
        stdout = context$1$0.sent;
        foundNullMatch = false;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 12;
        _iterator = _getIterator(stdout.split("\n"));

      case 14:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 25;
          break;
        }

        line = _step.value;
        foundMatch = searchRe.exec(line);

        if (!foundMatch) {
          context$1$0.next = 21;
          break;
        }

        return context$1$0.abrupt('return', { appPackage: foundMatch[1].trim(), appActivity: foundMatch[2].trim() });

      case 21:
        if (nullRe.test(line)) {
          foundNullMatch = true;
        }

      case 22:
        _iteratorNormalCompletion = true;
        context$1$0.next = 14;
        break;

      case 25:
        context$1$0.next = 31;
        break;

      case 27:
        context$1$0.prev = 27;
        context$1$0.t0 = context$1$0['catch'](12);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 31:
        context$1$0.prev = 31;
        context$1$0.prev = 32;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 34:
        context$1$0.prev = 34;

        if (!_didIteratorError) {
          context$1$0.next = 37;
          break;
        }

        throw _iteratorError;

      case 37:
        return context$1$0.finish(34);

      case 38:
        return context$1$0.finish(31);

      case 39:
        if (!foundNullMatch) {
          context$1$0.next = 43;
          break;
        }

        return context$1$0.abrupt('return', { appPackage: null, appActivity: null });

      case 43:
        _loggerJs2['default'].errorAndThrow("Could not parse activity from dumpsys");

      case 44:
        context$1$0.next = 49;
        break;

      case 46:
        context$1$0.prev = 46;
        context$1$0.t1 = context$1$0['catch'](4);

        _loggerJs2['default'].errorAndThrow('Could not get focusPackageAndActivity. Original error: ' + context$1$0.t1.message);

      case 49:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 46], [12, 27, 31, 39], [32,, 34, 38]]);
};

/**
 * Wait for the given activity to be focused/non-focused.
 *
 * @param {string} pkg - The name of the package to wait for.
 * @param {string} activity - The name of the activity, belonging to that package,
 *                            to wait for.
 * @param {boolean} waitForStop - Whether to wait until the activity is focused (true)
 *                                or is not focused (false).
 * @param {number} waitMs [20000] - Number of milliseconds to wait before timeout occurs.
 * @throws {error} If timeout happens.
 */
apkUtilsMethods.waitForActivityOrNot = function callee$0$0(pkg, activity, waitForStop) {
  var waitMs = arguments.length <= 3 || arguments[3] === undefined ? 20000 : arguments[3];

  var splitNames, allPackages, allActivities, possibleActivityNames, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, oneActivity, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, currentPkg, possibleActivityPatterns, retries;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(!pkg || !activity)) {
          context$1$0.next = 2;
          break;
        }

        throw new Error('Package and activity required.');

      case 2:
        _loggerJs2['default'].debug('Waiting up to ' + waitMs + 'ms for activity matching pkg: \'' + pkg + '\' and ' + ('activity: \'' + activity + '\' to' + (waitForStop ? ' not' : '') + ' be focused'));

        splitNames = function splitNames(names) {
          return names.split(',').map(function (name) {
            return name.trim();
          });
        };

        allPackages = splitNames(pkg);
        allActivities = splitNames(activity);
        possibleActivityNames = [];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 10;
        _iterator2 = _getIterator(allActivities);

      case 12:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 40;
          break;
        }

        oneActivity = _step2.value;

        if (!oneActivity.startsWith('.')) {
          context$1$0.next = 36;
          break;
        }

        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 18;

        // add the package name if activity is not full qualified
        for (_iterator3 = _getIterator(allPackages); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          currentPkg = _step3.value;

          possibleActivityNames.push(('' + currentPkg + oneActivity).replace(/\.+/g, '.'));
        }
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](18);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 26:
        context$1$0.prev = 26;
        context$1$0.prev = 27;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 29:
        context$1$0.prev = 29;

        if (!_didIteratorError3) {
          context$1$0.next = 32;
          break;
        }

        throw _iteratorError3;

      case 32:
        return context$1$0.finish(29);

      case 33:
        return context$1$0.finish(26);

      case 34:
        context$1$0.next = 37;
        break;

      case 36:
        // accept fully qualified activity name.
        possibleActivityNames.push(oneActivity);

      case 37:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 12;
        break;

      case 40:
        context$1$0.next = 46;
        break;

      case 42:
        context$1$0.prev = 42;
        context$1$0.t1 = context$1$0['catch'](10);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t1;

      case 46:
        context$1$0.prev = 46;
        context$1$0.prev = 47;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 49:
        context$1$0.prev = 49;

        if (!_didIteratorError2) {
          context$1$0.next = 52;
          break;
        }

        throw _iteratorError2;

      case 52:
        return context$1$0.finish(49);

      case 53:
        return context$1$0.finish(46);

      case 54:
        /* jshint ignore:start */
        _loggerJs2['default'].debug('Possible activities, to be checked: ' + possibleActivityNames.map(function (name) {
          return '\'' + name + '\'';
        }).join(', '));
        /* jshint ignore:end */
        possibleActivityPatterns = possibleActivityNames.map(function (possibleActivityName) {
          return new RegExp('^' + possibleActivityName.replace(/\./g, '\\.').replace(/\*/g, '.*?').replace(/\$/g, '\\$') + '$');
        });
        retries = parseInt(waitMs / 750, 10) || 1;

        retries = isNaN(retries) ? 30 : retries;
        context$1$0.next = 60;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 750, function callee$1$0() {
          var _ref, appPackage, appActivity, _ret;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getFocusedPackageAndActivity());

              case 2:
                _ref = context$2$0.sent;
                appPackage = _ref.appPackage;
                appActivity = _ref.appActivity;

                if (!(appActivity && appPackage)) {
                  context$2$0.next = 9;
                  break;
                }

                _ret = (function () {
                  var fullyQualifiedActivity = appActivity.startsWith('.') ? '' + appPackage + appActivity : appActivity;
                  _loggerJs2['default'].debug('Found package: \'' + appPackage + '\' and fully qualified activity name : \'' + fullyQualifiedActivity + '\'');
                  var foundAct = _lodash2['default'].includes(allPackages, appPackage) && _lodash2['default'].findIndex(possibleActivityPatterns, function (possiblePattern) {
                    return possiblePattern.test(fullyQualifiedActivity);
                  }) !== -1;
                  if (!waitForStop && foundAct || waitForStop && !foundAct) {
                    return {
                      v: undefined
                    };
                  }
                })();

                if (!(typeof _ret === 'object')) {
                  context$2$0.next = 9;
                  break;
                }

                return context$2$0.abrupt('return', _ret.v);

              case 9:
                _loggerJs2['default'].debug('Incorrect package and activity. Retrying.');
                /* jshint ignore:start */
                throw new Error(possibleActivityNames.map(function (name) {
                  return '\'' + name + '\'';
                }).join(' or ') + ' never ' + (waitForStop ? 'stopped' : 'started'));

              case 11:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }));

      case 60:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[10, 42, 46, 54], [18, 22, 26, 34], [27,, 29, 33], [47,, 49, 53]]);
};

/**
 * Wait for the given activity to be focused
 *
 * @param {string} pkg - The name of the package to wait for.
 * @param {string} activity - The name of the activity, belonging to that package,
 *                            to wait for.
 * @param {number} waitMs [20000] - Number of milliseconds to wait before timeout occurs.
 * @throws {error} If timeout happens.
 */

/* jshint ignore:end */
apkUtilsMethods.waitForActivity = function callee$0$0(pkg, act) {
  var waitMs = arguments.length <= 2 || arguments[2] === undefined ? 20000 : arguments[2];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.waitForActivityOrNot(pkg, act, false, waitMs));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Wait for the given activity to be non-focused.
 *
 * @param {string} pkg - The name of the package to wait for.
 * @param {string} activity - The name of the activity, belonging to that package,
 *                            to wait for.
 * @param {number} waitMs [20000] - Number of milliseconds to wait before timeout occurs.
 * @throws {error} If timeout happens.
 */
apkUtilsMethods.waitForNotActivity = function callee$0$0(pkg, act) {
  var waitMs = arguments.length <= 2 || arguments[2] === undefined ? 20000 : arguments[2];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.waitForActivityOrNot(pkg, act, true, waitMs));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Uninstall the given package from the device under test.
 *
 * @param {string} pkg - The name of the package to be uninstalled.
 * @return {boolean} True if the package was found on the device and
 *                   successfully uninstalled.
 */
apkUtilsMethods.uninstallApk = function callee$0$0(pkg) {
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Uninstalling ' + pkg);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.isAppInstalled(pkg));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 6;
          break;
        }

        _loggerJs2['default'].info(pkg + ' was not uninstalled, because it was not present on the device');
        return context$1$0.abrupt('return', false);

      case 6:
        stdout = undefined;
        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(this.forceStop(pkg));

      case 10:
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.adbExec(['uninstall', pkg], { timeout: 20000 }));

      case 12:
        stdout = context$1$0.sent;
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](7);

        _loggerJs2['default'].errorAndThrow('Unable to uninstall APK. Original error: ' + context$1$0.t0.message);

      case 18:
        stdout = stdout.trim();
        _loggerJs2['default'].debug('ADB command output: ' + stdout);

        if (!(stdout.indexOf("Success") !== -1)) {
          context$1$0.next = 23;
          break;
        }

        _loggerJs2['default'].info(pkg + ' was successfully uninstalled');
        return context$1$0.abrupt('return', true);

      case 23:
        _loggerJs2['default'].info(pkg + ' was not uninstalled');
        return context$1$0.abrupt('return', false);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 15]]);
};

/**
 * Install the package after it was pushed to the device under test.
 *
 * @param {string} apkPathOnDevice - The full path to the package on the device file system.
 * @param {object} opts [{}] - Additional exec options. See {@link https://github.com/appium/node-teen_process}
 *                             for more details on this parameter.
 * @throws {error} If there was a failure during application install.
 */
apkUtilsMethods.installFromDevicePath = function callee$0$0(apkPathOnDevice) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['pm', 'install', '-r', apkPathOnDevice], opts));

      case 2:
        stdout = context$1$0.sent;

        if (stdout.indexOf("Failure") !== -1) {
          _loggerJs2['default'].errorAndThrow('Remote install failed: ' + stdout);
        }

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Install the package from the local file system.
 *
 * @param {string} apk - The full path to the local package.
 * @param {boolean} repalce [true] - Whether to replace the package if it
 *                                   already installed. True by default.
 * @param {number} timeout [60000] - The number of milliseconds to wait until
 *                                   installation is completed.
 * @throws {error} If an unexpected error happens during install.
 */
apkUtilsMethods.install = function callee$0$0(apk) {
  var replace = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  var timeout = arguments.length <= 2 || arguments[2] === undefined ? 60000 : arguments[2];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!replace) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec(['install', '-r', apk], { timeout: timeout }));

      case 3:
        context$1$0.next = 15;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.adbExec(['install', apk], { timeout: timeout }));

      case 8:
        context$1$0.next = 15;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](5);

        if (!(context$1$0.t0.message.indexOf('INSTALL_FAILED_ALREADY_EXISTS') === -1)) {
          context$1$0.next = 14;
          break;
        }

        throw context$1$0.t0;

      case 14:
        _loggerJs2['default'].debug('Application \'' + apk + '\' already installed. Continuing.');

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 10]]);
};

/**
 * Install the package from the local file system of upgrade it if an older
 * version of the same package is already installed.
 *
 * @param {string} apk - The full path to the local package.
 * @param {?string} pkg - The name of the installed package. The method will
 *                        perform faster if it is set.
 * @param {number} timeout [60000] - The number of milliseconds to wait until
 *                                   installation is completed.
 * @throws {error} If an unexpected error happens during install.
 */
apkUtilsMethods.installOrUpgrade = function callee$0$0(apk) {
  var pkg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
  var timeout = arguments.length <= 2 || arguments[2] === undefined ? 60000 : arguments[2];
  var apkInfo, pkgInfo, pkgVersionCode, apkVersionCode;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        apkInfo = null;

        if (pkg) {
          context$1$0.next = 6;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getApkInfo(apk));

      case 4:
        apkInfo = context$1$0.sent;

        pkg = apkInfo.name;

      case 6:
        if (pkg) {
          context$1$0.next = 9;
          break;
        }

        _loggerJs2['default'].warn('Cannot read the package name of ' + apk + '. Assuming correct app version is already installed');
        return context$1$0.abrupt('return');

      case 9:
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.isAppInstalled(pkg));

      case 11:
        if (context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(this.install(apk, false, timeout));

      case 14:
        return context$1$0.abrupt('return');

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(this.getPackageInfo(pkg));

      case 17:
        pkgInfo = context$1$0.sent;
        pkgVersionCode = pkgInfo.versionCode;

        if (apkInfo) {
          context$1$0.next = 23;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(this.getApkInfo(apk));

      case 22:
        apkInfo = context$1$0.sent;

      case 23:
        apkVersionCode = apkInfo.versionCode;

        if (!(_lodash2['default'].isUndefined(apkVersionCode) || _lodash2['default'].isUndefined(pkgVersionCode))) {
          context$1$0.next = 27;
          break;
        }

        _loggerJs2['default'].warn('Cannot read version codes of ' + apk + ' and/or ' + pkg + '. Assuming correct app version is already installed');
        return context$1$0.abrupt('return');

      case 27:
        if (!(pkgVersionCode >= apkVersionCode)) {
          context$1$0.next = 30;
          break;
        }

        _loggerJs2['default'].debug('The installed "' + pkg + '" package does not require upgrade (' + pkgVersionCode + ' >= ' + apkVersionCode + ')');
        return context$1$0.abrupt('return');

      case 30:
        _loggerJs2['default'].debug('The installed "' + pkg + '" package is older than ' + apk + ' (' + pkgVersionCode + ' < ' + apkVersionCode + '). ' + 'Executing upgrade');
        context$1$0.prev = 31;
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(this.install(apk, true, timeout));

      case 34:
        context$1$0.next = 45;
        break;

      case 36:
        context$1$0.prev = 36;
        context$1$0.t0 = context$1$0['catch'](31);

        _loggerJs2['default'].warn('Cannot upgrade ' + pkg + ' because of "' + context$1$0.t0.message + '". Trying full reinstall');
        context$1$0.next = 41;
        return _regeneratorRuntime.awrap(this.uninstallApk(pkg));

      case 41:
        if (context$1$0.sent) {
          context$1$0.next = 43;
          break;
        }

        _loggerJs2['default'].errorAndThrow('"' + pkg + '" package cannot be uninstalled');

      case 43:
        context$1$0.next = 45;
        return _regeneratorRuntime.awrap(this.install(apk, false, timeout));

      case 45:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[31, 36]]);
};

/**
 * Extract string resources from the given package on local file system.
 *
 * @param {string} apk - The full path to the local package.
 * @param {string} language - The name of the language to extract the resources for.
 * @param {string} out - The name of the destination folder on the local file system to
 *                       store the extracted file to.
 * @return {object} A mapping object, where properties are: 'apkStrings', containing
 *                  parsed resource file represented as JSON object, and 'localPath',
 *                  containing the path to the extracted file on the local file system.
 */
apkUtilsMethods.extractStringsFromApk = function callee$0$0(apk, language, out) {
  var stringsJson, localPath, apkTools, args, fileData, apkStrings, msg;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Extracting strings for language: ' + (language || "default"));
        stringsJson = 'strings.json';
        localPath = undefined;

        if (language) {
          context$1$0.next = 7;
          break;
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getDeviceLanguage());

      case 6:
        language = context$1$0.sent;

      case 7:
        apkTools = this.jars['appium_apk_tools.jar'];
        args = ['-jar', apkTools, 'stringsFromApk', apk, out, language];
        fileData = undefined, apkStrings = undefined;
        context$1$0.prev = 10;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('java', args));

      case 13:
        context$1$0.next = 21;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](10);

        _loggerJs2['default'].debug('No strings.xml for language \'' + language + '\', getting default ' + 'strings.xml');
        args.pop();
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('java', args));

      case 21:
        context$1$0.prev = 21;

        _loggerJs2['default'].debug("Reading strings from converted strings.json");
        localPath = _path2['default'].join(out, stringsJson);
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localPath, 'utf8'));

      case 26:
        fileData = context$1$0.sent;

        apkStrings = JSON.parse(fileData);
        context$1$0.next = 35;
        break;

      case 30:
        context$1$0.prev = 30;
        context$1$0.t1 = context$1$0['catch'](21);

        if (fileData) {
          _loggerJs2['default'].debug('Content started with: ' + fileData.slice(0, 300));
        }
        msg = 'Could not parse strings from strings.json. Original ' + ('error: ' + context$1$0.t1.message);

        _loggerJs2['default'].errorAndThrow(msg);

      case 35:
        return context$1$0.abrupt('return', { apkStrings: apkStrings, localPath: localPath });

      case 36:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[10, 15], [21, 30]]);
};

/**
 * Get the language name of the device under test.
 *
 * @return {string} The name of device language.
 */
apkUtilsMethods.getDeviceLanguage = function callee$0$0() {
  var language;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        language = undefined;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getApiLevel());

      case 3:
        context$1$0.t0 = context$1$0.sent;

        if (!(context$1$0.t0 < 23)) {
          context$1$0.next = 14;
          break;
        }

        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.getDeviceSysLanguage());

      case 7:
        language = context$1$0.sent;

        if (language) {
          context$1$0.next = 12;
          break;
        }

        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.getDeviceProductLanguage());

      case 11:
        language = context$1$0.sent;

      case 12:
        context$1$0.next = 17;
        break;

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(this.getDeviceLocale());

      case 16:
        language = context$1$0.sent.split("-")[0];

      case 17:
        return context$1$0.abrupt('return', language);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the language name of the device under test.
 *
 * @param {string} language - The name of the new device language.
 */
apkUtilsMethods.setDeviceLanguage = function callee$0$0(language) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceSysLanguage(language));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the country name of the device under test.
 *
 * @return {string} The name of device country.
 */
apkUtilsMethods.getDeviceCountry = function callee$0$0() {
  var country;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceSysCountry());

      case 2:
        country = context$1$0.sent;

        if (country) {
          context$1$0.next = 7;
          break;
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getDeviceProductCountry());

      case 6:
        country = context$1$0.sent;

      case 7:
        return context$1$0.abrupt('return', country);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the country name of the device under test.
 *
 * @param {string} country - The name of the new device country.
 */
apkUtilsMethods.setDeviceCountry = function callee$0$0(country) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceSysCountry(country));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the locale name of the device under test.
 *
 * @return {string} The name of device locale.
 */
apkUtilsMethods.getDeviceLocale = function callee$0$0() {
  var locale;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.getDeviceSysLocale());

      case 2:
        locale = context$1$0.sent;

        if (locale) {
          context$1$0.next = 7;
          break;
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getDeviceProductLocale());

      case 6:
        locale = context$1$0.sent;

      case 7:
        return context$1$0.abrupt('return', locale);

      case 8:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Set the locale name of the device under test.
 *
 * @param {string} locale - The name of the new device country.
 */
apkUtilsMethods.setDeviceLocale = function callee$0$0(locale) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.setDeviceSysLocale(locale));

      case 2:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the package name from local apk file.
 *
 * @param {string} apk - The full path to existing .apk package on the local
 *                       file system.
 * @return {string} The parsed package name or _null_ if it cannot be parsed.
 */
apkUtilsMethods.getPackageName = function callee$0$0(apk) {
  var args, _ref2, stdout, apkPackage;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['dump', 'badging', apk];
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, args));

      case 5:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        apkPackage = new RegExp(/package: name='([^']+)'/g).exec(stdout);

        if (apkPackage && apkPackage.length >= 2) {
          apkPackage = apkPackage[1];
        } else {
          apkPackage = null;
        }
        return context$1$0.abrupt('return', apkPackage);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Objcet} AppInfo
 * @property {string} name - Package name, for example 'com.acme.app'.
 * @property {number} versionCode - Version code.
 * @property {string} versionName - Version name, for example '1.0'.
 */

/**
 * Get the package info from local apk file.
 *
 * @param {string} apkPath - The full path to existing .apk package on the local
 *                           file system.
 * @return {?AppInfo} The parsed application information.
 */
apkUtilsMethods.getApkInfo = function callee$0$0(apkPath) {
  var _ref3, stdout, matches;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apkPath));

      case 2:
        if (context$1$0.sent) {
          context$1$0.next = 4;
          break;
        }

        _loggerJs2['default'].errorAndThrow('The file at path ' + apkPath + ' does not exist or is not accessible');

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 6:
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['d', 'badging', apkPath]));

      case 9:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;
        matches = new RegExp(/package: name='([^']+)' versionCode='(\d+)' versionName='([^']+)'/).exec(stdout);

        if (!matches) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt('return', {
          name: matches[1],
          versionCode: parseInt(matches[2], 10),
          versionName: matches[3]
        });

      case 14:
        context$1$0.next = 19;
        break;

      case 16:
        context$1$0.prev = 16;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Error "' + context$1$0.t0.message + '" while getting badging info');

      case 19:
        return context$1$0.abrupt('return', {});

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 16]]);
};

/**
 * Get the package info from the installed application.
 *
 * @param {string} pkg - The name of the installed package.
 * @return {?AppInfo} The parsed application information.
 */
apkUtilsMethods.getPackageInfo = function callee$0$0(pkg) {
  var result, stdout, versionNameMatch, versionCodeMatch;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Getting package info for ' + pkg);
        result = { name: pkg };
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'package', pkg]));

      case 5:
        stdout = context$1$0.sent;
        versionNameMatch = new RegExp(/versionName=([\d+\.]+)/).exec(stdout);

        if (versionNameMatch) {
          result.versionName = versionNameMatch[1];
        }
        versionCodeMatch = new RegExp(/versionCode=(\d+)/).exec(stdout);

        if (versionCodeMatch) {
          result.versionCode = parseInt(versionCodeMatch[1], 10);
        }
        return context$1$0.abrupt('return', result);

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](2);

        _loggerJs2['default'].warn('Error "' + context$1$0.t0.message + '" while dumping package info');

      case 16:
        return context$1$0.abrupt('return', result);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 13]]);
};

exports['default'] = apkUtilsMethods;
module.exports = exports['default'];
// https://regex101.com/r/xZ8vF7/1

// figure out the number of retries. Try once if waitMs is less that 750
// 30 times if parsing is not possible

// on some systems this will throw an error if the app already
// exists

// this method is only used in API < 23

// this method is only used in API < 23

// this method is only used in API < 23

// this method is only used in API >= 23

// this method is only used in API >= 23
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hcGstdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3lCQUE4QixlQUFlOzs0QkFDeEIsY0FBYzs7d0JBQ25CLGNBQWM7Ozs7b0JBQ2IsTUFBTTs7OztzQkFDVCxRQUFROzs7O3dCQUNRLFVBQVU7OzZCQUNyQixnQkFBZ0I7O0FBR25DLElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7QUFRekIsZUFBZSxDQUFDLGNBQWMsR0FBRyxvQkFBZ0IsR0FBRztNQUU1QyxTQUFTLEVBRVQsTUFBTSxFQUNOLGVBQWU7Ozs7O0FBSGYsaUJBQVMsR0FBRyxLQUFLOztBQUNyQiw4QkFBSSxLQUFLLGlDQUErQixHQUFHLENBQUcsQ0FBQzs7eUNBQzVCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQzs7O0FBQTFELGNBQU07QUFDTix1QkFBZSxHQUFHLElBQUksTUFBTSxlQUFhLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxRQUFLLEdBQUcsQ0FBQzs7QUFDbEYsaUJBQVMsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3pDLDhCQUFJLEtBQUssYUFBVSxDQUFDLFNBQVMsR0FBRyxNQUFNLEdBQUcsRUFBRSxDQUFBLGdCQUFhLENBQUM7NENBQ2xELFNBQVM7Ozs7OztBQUVoQiw4QkFBSSxhQUFhLHlEQUF1RCxlQUFFLE9BQU8sQ0FBRyxDQUFDOzs7Ozs7O0NBRXhGLENBQUM7Ozs7Ozs7O0FBUUYsZUFBZSxDQUFDLFFBQVEsR0FBRyxvQkFBZ0IsR0FBRyxFQUFFLEdBQUc7TUFLM0MsSUFBSTs7OztBQUpWLFlBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7QUFDaEIsZ0NBQUksYUFBYSxDQUFDLHdDQUF3QyxDQUFDLENBQUM7U0FDN0Q7O0FBRUssWUFBSSxHQUFHLENB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RixNQUFNLEVBQ04sZ0JBQWdCLEVBSWhCLGdCQUFnQjs7OztBQVJ4Qiw4QkFBSSxLQUFLLCtCQUE2QixHQUFHLENBQUcsQ0FBQztBQUN6QyxjQUFNLEdBQUcsRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFDOzs7eUNBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7OztBQUF0RCxjQUFNO0FBQ04sd0JBQWdCLEdBQUcsSUFBSSxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDOztBQUMxRSxZQUFJLGdCQUFnQixFQUFFO0FBQ3BCLGdCQUFNLENBQUMsV0FBVyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFDO0FBQ0ssd0JBQWdCLEdBQUcsSUFBSSxNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDOztBQUNyRSxZQUFJLGdCQUFnQixFQUFFO0FBQ3BCLGdCQUFNLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUN4RDs0Q0FDTSxNQUFNOzs7Ozs7QUFFYiw4QkFBSSxJQUFJLGFBQVcsZUFBSSxPQUFPLGtDQUErQixDQUFDOzs7NENBRXpELE1BQU07Ozs7Ozs7Q0FDZCxDQUFDOztxQkFFYSxlQUFlIiwiZmlsZSI6ImxpYi90b29scy9hcGstdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWlsZFN0YXJ0Q21kIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcblxuXG5sZXQgYXBrVXRpbHNNZXRob2RzID0ge307XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcGFydGljdWxhciBwYWNrYWdlIGlzIHByZXNlbnQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwa2cgLSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhY2thZ2UgaXMgaW5zdGFsbGVkLlxuICovXG5hcGtVdGlsc01ldGhvZHMuaXNBcHBJbnN0YWxsZWQgPSBhc3luYyBmdW5jdGlvbiAocGtnKSB7XG4gIHRyeSB7XG4gICAgbGV0IGluc3RhbGxlZCA9IGZhbHNlO1xuICAgIGxvZy5kZWJ1ZyhgR2V0dGluZyBpbnN0YWxsIHN0YXR1cyBmb3IgJHtwa2d9YCk7XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdsaXN0JywgJ3BhY2thZ2VzJywgcGtnXSk7XG4gICAgbGV0IGFwa0luc3RhbGxlZFJneCA9IG5ldyBSZWdFeHAoYF5wYWNrYWdlOiR7cGtnLnJlcGxhY2UoLyhcXC4pL2csIFwiXFxcXCQxXCIpfSRgLCAnbScpO1xuICAgIGluc3RhbGxlZCA9IGFwa0luc3RhbGxlZFJneC50ZXN0KHN0ZG91dCk7XG4gICAgbG9nLmRlYnVnKGBBcHAgaXMkeyFpbnN0YWxsZWQgPyAnIG5vdCcgOiAnJ30gaW5zdGFsbGVkYCk7XG4gICAgcmV0dXJuIGluc3RhbGxlZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBmaW5kaW5nIGlmIGFwcCBpcyBpbnN0YWxsZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCB0aGUgcGFydGljdWxhciBVUkkgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgbmFtZSBvZiBVUkkgdG8gc3RhcnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gc3RhcnQgdGhlIFVSSSB3aXRoLlxuICovXG5hcGtVdGlsc01ldGhvZHMuc3RhcnRVcmkgPSBhc3luYyBmdW5jdGlvbiAodXJpLCBwa2cpIHtcbiAgaWYgKCF1cmkgfHwgIXBrZykge1xuICAgIGxvZy5lcnJvckFuZFRocm93KFwiVVJJIGFuZCBwYWNrYWdlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgYXJncyA9IFtcImFtXCIsIFwic3RhcnRcIiwgXCItV1wiLCBcIi1hXCIsIFwiYW5kcm9pZC5pbnRlbnQuYWN0aW9uLlZJRVdcIiwgXCItZFwiLFxuICAgICAgICAgICAgICAgIHVyaSwgcGtnXTtcbiAgICBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEVycm9yIGF0dGVtcHRpbmcgdG8gc3RhcnQgVVJJLiBPcmlnaW5hbCBlcnJvcjogJHtlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IHRoZSBwYXJ0aWN1bGFyIHBhY2thZ2Ugb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGFydEFwcE9wdGlvbnMgW3t9XSAtIFN0YXJ0dXAgb3B0aW9ucyBtYXBwaW5nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgaXMgbWFuZGF0b3J5IHRoYXQgJ2FjdGl2aXR5JyBhbmQgJ3BrZycgcHJvcGVydGllcyBhcmUgc2V0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWRkaXRpb25hbCBzdXBwb3J0ZWQgcHJvcGVydGllcyBhcmU6ICdyZXRyeScsICdzdG9wQXBwJywgJ3dhaXRQa2cnXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgJ3dhaXRBY3Rpdml0eScuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBvdXRwdXQgb2YgdGhlIGNvcnJlc3BvbmRpbmcgYWRiIGNvbW1hbmQuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5zdGFydEFwcCA9IGFzeW5jIGZ1bmN0aW9uIChzdGFydEFwcE9wdGlvbnMgPSB7fSkge1xuICB0cnkge1xuICAgIGlmICghc3RhcnRBcHBPcHRpb25zLmFjdGl2aXR5IHx8ICFzdGFydEFwcE9wdGlvbnMucGtnKSB7XG4gICAgICBsb2cuZXJyb3JBbmRUaHJvdyhcImFjdGl2aXR5IGFuZCBwa2cgaXMgcmVxdWlyZWQgZm9yIGxhdW5jaGluZyBhcHBsaWNhdGlvblwiKTtcbiAgICB9XG4gICAgc3RhcnRBcHBPcHRpb25zID0gXy5jbG9uZShzdGFydEFwcE9wdGlvbnMpO1xuICAgIHN0YXJ0QXBwT3B0aW9ucy5hY3Rpdml0eSA9IHN0YXJ0QXBwT3B0aW9ucy5hY3Rpdml0eS5yZXBsYWNlKCckJywgJ1xcXFwkJyk7XG5cbiAgICAvLyBpbml0aWFsaXppbmcgZGVmYXVsdHNcbiAgICBfLmRlZmF1bHRzKHN0YXJ0QXBwT3B0aW9ucywge1xuICAgICAgd2FpdFBrZzogc3RhcnRBcHBPcHRpb25zLnBrZyxcbiAgICAgIHdhaXRBY3Rpdml0eTogZmFsc2UsXG4gICAgICByZXRyeTogdHJ1ZSxcbiAgICAgIHN0b3BBcHA6IHRydWVcbiAgICB9KTtcbiAgICAvLyBwcmV2ZW50aW5nIG51bGwgd2FpdHBrZ1xuICAgIHN0YXJ0QXBwT3B0aW9ucy53YWl0UGtnID0gc3RhcnRBcHBPcHRpb25zLndhaXRQa2cgfHwgc3RhcnRBcHBPcHRpb25zLnBrZztcbiAgICBsZXQgYXBpTGV2ZWwgPSBhd2FpdCB0aGlzLmdldEFwaUxldmVsKCk7XG4gICAgbGV0IGNtZCA9IGJ1aWxkU3RhcnRDbWQoc3RhcnRBcHBPcHRpb25zLCBhcGlMZXZlbCk7XG4gICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoY21kKTtcbiAgICBpZiAoc3Rkb3V0LmluZGV4T2YoXCJFcnJvcjogQWN0aXZpdHkgY2xhc3NcIikgIT09IC0xICYmXG4gICAgICAgIHN0ZG91dC5pbmRleE9mKFwiZG9lcyBub3QgZXhpc3RcIikgIT09IC0xKSB7XG4gICAgICBpZiAoc3RhcnRBcHBPcHRpb25zLnJldHJ5ICYmIHN0YXJ0QXBwT3B0aW9ucy5hY3Rpdml0eVswXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgbG9nLmRlYnVnKFwiV2UgdHJpZWQgdG8gc3RhcnQgYW4gYWN0aXZpdHkgdGhhdCBkb2Vzbid0IGV4aXN0LCBcIiArXG4gICAgICAgICAgICAgICAgICBcInJldHJ5aW5nIHdpdGggLiBwcmVwZW5kZWQgdG8gYWN0aXZpdHlcIik7XG4gICAgICAgIHN0YXJ0QXBwT3B0aW9ucy5hY3Rpdml0eSA9IGAuJHtzdGFydEFwcE9wdGlvbnMuYWN0aXZpdHl9YDtcbiAgICAgICAgc3RhcnRBcHBPcHRpb25zLnJldHJ5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0QXBwKHN0YXJ0QXBwT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhcIkFjdGl2aXR5IHVzZWQgdG8gc3RhcnQgYXBwIGRvZXNuJ3QgZXhpc3Qgb3IgY2Fubm90IGJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsYXVuY2hlZCEgTWFrZSBzdXJlIGl0IGV4aXN0cyBhbmQgaXMgYSBsYXVuY2hhYmxlIGFjdGl2aXR5XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3Rkb3V0LmluZGV4T2YoXCJqYXZhLmxhbmcuU2VjdXJpdHlFeGNlcHRpb25cIikgIT09IC0xKSB7XG4gICAgICAvLyBpZiB0aGUgYXBwIGlzIGRpc2FibGVkIG9uIGEgcmVhbCBkZXZpY2UgaXQgd2lsbCB0aHJvdyBhIHNlY3VyaXR5IGV4Y2VwdGlvblxuICAgICAgbG9nLmVycm9yQW5kVGhyb3coXCJQZXJtaXNzaW9uIHRvIHN0YXJ0IGFjdGl2aXR5IGRlbmllZC5cIik7XG4gICAgfVxuICAgIGlmIChzdGFydEFwcE9wdGlvbnMud2FpdEFjdGl2aXR5KSB7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JBY3Rpdml0eShzdGFydEFwcE9wdGlvbnMud2FpdFBrZywgc3RhcnRBcHBPcHRpb25zLndhaXRBY3Rpdml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QXBwT3B0aW9ucy53YWl0RHVyYXRpb24pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBFcnJvciBvY2N1cmVkIHdoaWxlIHN0YXJ0aW5nIEFwcC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhY2thZ2VBY3Rpdml0eUluZm9cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gYXBwUGFja2FnZSAtIFRoZSBuYW1lIG9mIGFwcGxpY2F0aW9uIHBhY2thZ2UsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSAnY29tLmFjbWUuYXBwJy5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gYXBwQWN0aXZpdHkgLSBUaGUgbmFtZSBvZiBtYWluIGFwcGxpY2F0aW9uIGFjdGl2aXR5LlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIGN1cnJlbnRseSBmb2N1c2VkIHBhY2thZ2UgYW5kIGFjdGl2aXR5LlxuICpcbiAqIEByZXR1cm4ge1BhY2thZ2VBY3Rpdml0eUluZm99IFRoZSBtYXBwaW5nLCB3aGVyZSBwcm9wZXJ0eSBuYW1lcyBhcmUgJ2FwcFBhY2thZ2UnIGFuZCAnYXBwQWN0aXZpdHknLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFuIGVycm9yIHdoaWxlIHBhcnNpbmcgdGhlIGRhdGEuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5nZXRGb2N1c2VkUGFja2FnZUFuZEFjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoXCJHZXR0aW5nIGZvY3VzZWQgcGFja2FnZSBhbmQgYWN0aXZpdHlcIik7XG4gIGxldCBjbWQgPSBbJ2R1bXBzeXMnLCAnd2luZG93JywgJ3dpbmRvd3MnXTtcbiAgbGV0IG51bGxSZSA9IG5ldyBSZWdFeHAoL21Gb2N1c2VkQXBwPW51bGwvKTtcbiAgbGV0IHNlYXJjaFJlID0gbmV3IFJlZ0V4cCgnbUZvY3VzZWRBcHAuK1JlY29yZFxcXFx7LipcXFxccyhbXlxcXFxzXFxcXC9cXFxcfV0rKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcLyhbXlxcXFxzXFxcXC9cXFxcfVxcXFwsXSspXFxcXCw/KFxcXFxzW15cXFxcc1xcXFwvXFxcXH1dKykqXFxcXH0nKTsgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci94Wjh2RjcvMVxuICB0cnkge1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGNtZCk7XG4gICAgbGV0IGZvdW5kTnVsbE1hdGNoID0gZmFsc2U7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGxldCBmb3VuZE1hdGNoID0gc2VhcmNoUmUuZXhlYyhsaW5lKTtcbiAgICAgIGlmIChmb3VuZE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7YXBwUGFja2FnZTogZm91bmRNYXRjaFsxXS50cmltKCksIGFwcEFjdGl2aXR5OiBmb3VuZE1hdGNoWzJdLnRyaW0oKX07XG4gICAgICB9IGVsc2UgaWYgKG51bGxSZS50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGZvdW5kTnVsbE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kTnVsbE1hdGNoKSB7XG4gICAgICByZXR1cm4ge2FwcFBhY2thZ2U6IG51bGwsIGFwcEFjdGl2aXR5OiBudWxsfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coXCJDb3VsZCBub3QgcGFyc2UgYWN0aXZpdHkgZnJvbSBkdW1wc3lzXCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBDb3VsZCBub3QgZ2V0IGZvY3VzUGFja2FnZUFuZEFjdGl2aXR5LiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FpdCBmb3IgdGhlIGdpdmVuIGFjdGl2aXR5IHRvIGJlIGZvY3VzZWQvbm9uLWZvY3VzZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIHdhaXQgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIGFjdGl2aXR5LCBiZWxvbmdpbmcgdG8gdGhhdCBwYWNrYWdlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCBmb3IuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHdhaXRGb3JTdG9wIC0gV2hldGhlciB0byB3YWl0IHVudGlsIHRoZSBhY3Rpdml0eSBpcyBmb2N1c2VkICh0cnVlKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGlzIG5vdCBmb2N1c2VkIChmYWxzZSkuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdE1zIFsyMDAwMF0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRpbWVvdXQgb2NjdXJzLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRpbWVvdXQgaGFwcGVucy5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLndhaXRGb3JBY3Rpdml0eU9yTm90ID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgYWN0aXZpdHksIHdhaXRGb3JTdG9wLCB3YWl0TXMgPSAyMDAwMCkge1xuICBpZiAoIXBrZyB8fCAhYWN0aXZpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2thZ2UgYW5kIGFjdGl2aXR5IHJlcXVpcmVkLicpO1xuICB9XG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3dhaXRNc31tcyBmb3IgYWN0aXZpdHkgbWF0Y2hpbmcgcGtnOiAnJHtwa2d9JyBhbmQgYCArXG4gICAgICAgICAgICBgYWN0aXZpdHk6ICcke2FjdGl2aXR5fScgdG8ke3dhaXRGb3JTdG9wID8gJyBub3QnIDogJyd9IGJlIGZvY3VzZWRgKTtcblxuICBjb25zdCBzcGxpdE5hbWVzID0gKG5hbWVzKSA9PiBuYW1lcy5zcGxpdCgnLCcpLm1hcCgobmFtZSkgPT4gbmFtZS50cmltKCkpO1xuXG4gIGNvbnN0IGFsbFBhY2thZ2VzID0gc3BsaXROYW1lcyhwa2cpO1xuICBjb25zdCBhbGxBY3Rpdml0aWVzID0gc3BsaXROYW1lcyhhY3Rpdml0eSk7XG5cbiAgbGV0IHBvc3NpYmxlQWN0aXZpdHlOYW1lcyA9IFtdO1xuICBmb3IgKGxldCBvbmVBY3Rpdml0eSBvZiBhbGxBY3Rpdml0aWVzKSB7XG4gICAgaWYgKG9uZUFjdGl2aXR5LnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgLy8gYWRkIHRoZSBwYWNrYWdlIG5hbWUgaWYgYWN0aXZpdHkgaXMgbm90IGZ1bGwgcXVhbGlmaWVkXG4gICAgICBmb3IgKGxldCBjdXJyZW50UGtnIG9mIGFsbFBhY2thZ2VzKSB7XG4gICAgICAgIHBvc3NpYmxlQWN0aXZpdHlOYW1lcy5wdXNoKGAke2N1cnJlbnRQa2d9JHtvbmVBY3Rpdml0eX1gLnJlcGxhY2UoL1xcLisvZywgJy4nKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFjY2VwdCBmdWxseSBxdWFsaWZpZWQgYWN0aXZpdHkgbmFtZS5cbiAgICAgIHBvc3NpYmxlQWN0aXZpdHlOYW1lcy5wdXNoKG9uZUFjdGl2aXR5KTtcbiAgICB9XG4gIH1cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBsb2cuZGVidWcoYFBvc3NpYmxlIGFjdGl2aXRpZXMsIHRvIGJlIGNoZWNrZWQ6ICR7cG9zc2libGVBY3Rpdml0eU5hbWVzLm1hcCgobmFtZSkgPT4gYCcke25hbWV9J2ApLmpvaW4oJywgJyl9YCk7XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gIGxldCBwb3NzaWJsZUFjdGl2aXR5UGF0dGVybnMgPSBwb3NzaWJsZUFjdGl2aXR5TmFtZXMubWFwKChwb3NzaWJsZUFjdGl2aXR5TmFtZSkgPT5cbiAgICBuZXcgUmVnRXhwKGBeJHtwb3NzaWJsZUFjdGl2aXR5TmFtZS5yZXBsYWNlKC9cXC4vZywgJ1xcXFwuJykucmVwbGFjZSgvXFwqL2csICcuKj8nKS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJyl9JGApXG4gICk7XG5cbiAgLy8gZmlndXJlIG91dCB0aGUgbnVtYmVyIG9mIHJldHJpZXMuIFRyeSBvbmNlIGlmIHdhaXRNcyBpcyBsZXNzIHRoYXQgNzUwXG4gIC8vIDMwIHRpbWVzIGlmIHBhcnNpbmcgaXMgbm90IHBvc3NpYmxlXG4gIGxldCByZXRyaWVzID0gcGFyc2VJbnQod2FpdE1zIC8gNzUwLCAxMCkgfHwgMTtcbiAgcmV0cmllcyA9IGlzTmFOKHJldHJpZXMpID8gMzAgOiByZXRyaWVzO1xuICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDc1MCwgYXN5bmMgKCkgPT4ge1xuICAgIGxldCB7YXBwUGFja2FnZSwgYXBwQWN0aXZpdHl9ID0gYXdhaXQgdGhpcy5nZXRGb2N1c2VkUGFja2FnZUFuZEFjdGl2aXR5KCk7XG4gICAgaWYgKGFwcEFjdGl2aXR5ICYmIGFwcFBhY2thZ2UpIHtcbiAgICAgIGxldCBmdWxseVF1YWxpZmllZEFjdGl2aXR5ID0gYXBwQWN0aXZpdHkuc3RhcnRzV2l0aCgnLicpID8gYCR7YXBwUGFja2FnZX0ke2FwcEFjdGl2aXR5fWAgOiBhcHBBY3Rpdml0eTtcbiAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgcGFja2FnZTogJyR7YXBwUGFja2FnZX0nIGFuZCBmdWxseSBxdWFsaWZpZWQgYWN0aXZpdHkgbmFtZSA6ICcke2Z1bGx5UXVhbGlmaWVkQWN0aXZpdHl9J2ApO1xuICAgICAgbGV0IGZvdW5kQWN0ID0gKF8uaW5jbHVkZXMoYWxsUGFja2FnZXMsIGFwcFBhY2thZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgXy5maW5kSW5kZXgocG9zc2libGVBY3Rpdml0eVBhdHRlcm5zLCAocG9zc2libGVQYXR0ZXJuKSA9PiBwb3NzaWJsZVBhdHRlcm4udGVzdChmdWxseVF1YWxpZmllZEFjdGl2aXR5KSkgIT09IC0xKTtcbiAgICAgIGlmICgoIXdhaXRGb3JTdG9wICYmIGZvdW5kQWN0KSB8fCAod2FpdEZvclN0b3AgJiYgIWZvdW5kQWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZygnSW5jb3JyZWN0IHBhY2thZ2UgYW5kIGFjdGl2aXR5LiBSZXRyeWluZy4nKTtcbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3Bvc3NpYmxlQWN0aXZpdHlOYW1lcy5tYXAoKG5hbWUpID0+IGAnJHtuYW1lfSdgKS5qb2luKCcgb3IgJyl9IG5ldmVyICR7d2FpdEZvclN0b3AgPyAnc3RvcHBlZCcgOiAnc3RhcnRlZCd9YCk7XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgfSk7XG59O1xuXG4vKipcbiAqIFdhaXQgZm9yIHRoZSBnaXZlbiBhY3Rpdml0eSB0byBiZSBmb2N1c2VkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIHdhaXQgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGl2aXR5IC0gVGhlIG5hbWUgb2YgdGhlIGFjdGl2aXR5LCBiZWxvbmdpbmcgdG8gdGhhdCBwYWNrYWdlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdE1zIFsyMDAwMF0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHRpbWVvdXQgb2NjdXJzLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRpbWVvdXQgaGFwcGVucy5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLndhaXRGb3JBY3Rpdml0eSA9IGFzeW5jIGZ1bmN0aW9uIChwa2csIGFjdCwgd2FpdE1zID0gMjAwMDApIHtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yQWN0aXZpdHlPck5vdChwa2csIGFjdCwgZmFsc2UsIHdhaXRNcyk7XG59O1xuXG4vKipcbiAqIFdhaXQgZm9yIHRoZSBnaXZlbiBhY3Rpdml0eSB0byBiZSBub24tZm9jdXNlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gd2FpdCBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aXZpdHkgLSBUaGUgbmFtZSBvZiB0aGUgYWN0aXZpdHksIGJlbG9uZ2luZyB0byB0aGF0IHBhY2thZ2UsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB3YWl0IGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0TXMgWzIwMDAwXSAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgdGltZW91dCBvY2N1cnMuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgdGltZW91dCBoYXBwZW5zLlxuICovXG5hcGtVdGlsc01ldGhvZHMud2FpdEZvck5vdEFjdGl2aXR5ID0gYXN5bmMgZnVuY3Rpb24gKHBrZywgYWN0LCB3YWl0TXMgPSAyMDAwMCkge1xuICBhd2FpdCB0aGlzLndhaXRGb3JBY3Rpdml0eU9yTm90KHBrZywgYWN0LCB0cnVlLCB3YWl0TXMpO1xufTtcblxuLyoqXG4gKiBVbmluc3RhbGwgdGhlIGdpdmVuIHBhY2thZ2UgZnJvbSB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGJlIHVuaW5zdGFsbGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFja2FnZSB3YXMgZm91bmQgb24gdGhlIGRldmljZSBhbmRcbiAqICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWxseSB1bmluc3RhbGxlZC5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLnVuaW5zdGFsbEFwayA9IGFzeW5jIGZ1bmN0aW9uIChwa2cpIHtcbiAgbG9nLmRlYnVnKGBVbmluc3RhbGxpbmcgJHtwa2d9YCk7XG4gIGlmICghYXdhaXQgdGhpcy5pc0FwcEluc3RhbGxlZChwa2cpKSB7XG4gICAgbG9nLmluZm8oYCR7cGtnfSB3YXMgbm90IHVuaW5zdGFsbGVkLCBiZWNhdXNlIGl0IHdhcyBub3QgcHJlc2VudCBvbiB0aGUgZGV2aWNlYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBzdGRvdXQ7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5mb3JjZVN0b3AocGtnKTtcbiAgICBzdGRvdXQgPSBhd2FpdCB0aGlzLmFkYkV4ZWMoWyd1bmluc3RhbGwnLCBwa2ddLCB7dGltZW91dDogMjAwMDB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBVbmFibGUgdG8gdW5pbnN0YWxsIEFQSy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIHN0ZG91dCA9IHN0ZG91dC50cmltKCk7XG4gIGxvZy5kZWJ1ZyhgQURCIGNvbW1hbmQgb3V0cHV0OiAke3N0ZG91dH1gKTtcbiAgaWYgKHN0ZG91dC5pbmRleE9mKFwiU3VjY2Vzc1wiKSAhPT0gLTEpIHtcbiAgICBsb2cuaW5mbyhgJHtwa2d9IHdhcyBzdWNjZXNzZnVsbHkgdW5pbnN0YWxsZWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsb2cuaW5mbyhgJHtwa2d9IHdhcyBub3QgdW5pbnN0YWxsZWRgKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbnN0YWxsIHRoZSBwYWNrYWdlIGFmdGVyIGl0IHdhcyBwdXNoZWQgdG8gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGtQYXRoT25EZXZpY2UgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBwYWNrYWdlIG9uIHRoZSBkZXZpY2UgZmlsZSBzeXN0ZW0uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0cyBbe31dIC0gQWRkaXRpb25hbCBleGVjIG9wdGlvbnMuIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgcGFyYW1ldGVyLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRoZXJlIHdhcyBhIGZhaWx1cmUgZHVyaW5nIGFwcGxpY2F0aW9uIGluc3RhbGwuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5pbnN0YWxsRnJvbURldmljZVBhdGggPSBhc3luYyBmdW5jdGlvbiAoYXBrUGF0aE9uRGV2aWNlLCBvcHRzID0ge30pIHtcbiAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoWydwbScsICdpbnN0YWxsJywgJy1yJywgYXBrUGF0aE9uRGV2aWNlXSwgb3B0cyk7XG4gIGlmIChzdGRvdXQuaW5kZXhPZihcIkZhaWx1cmVcIikgIT09IC0xKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFJlbW90ZSBpbnN0YWxsIGZhaWxlZDogJHtzdGRvdXR9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zdGFsbCB0aGUgcGFja2FnZSBmcm9tIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgcGFja2FnZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwYWxjZSBbdHJ1ZV0gLSBXaGV0aGVyIHRvIHJlcGxhY2UgdGhlIHBhY2thZ2UgaWYgaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5IGluc3RhbGxlZC4gVHJ1ZSBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgWzYwMDAwXSAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YWxsYXRpb24gaXMgY29tcGxldGVkLlxuICogQHRocm93cyB7ZXJyb3J9IElmIGFuIHVuZXhwZWN0ZWQgZXJyb3IgaGFwcGVucyBkdXJpbmcgaW5zdGFsbC5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLmluc3RhbGwgPSBhc3luYyBmdW5jdGlvbiAoYXBrLCByZXBsYWNlID0gdHJ1ZSwgdGltZW91dCA9IDYwMDAwKSB7XG4gIGlmIChyZXBsYWNlKSB7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnaW5zdGFsbCcsICctcicsIGFwa10sIHt0aW1lb3V0fSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2luc3RhbGwnLCBhcGtdLCB7dGltZW91dH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gb24gc29tZSBzeXN0ZW1zIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYXBwIGFscmVhZHlcbiAgICAgIC8vIGV4aXN0c1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ0lOU1RBTExfRkFJTEVEX0FMUkVBRFlfRVhJU1RTJykgPT09IC0xKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGxvZy5kZWJ1ZyhgQXBwbGljYXRpb24gJyR7YXBrfScgYWxyZWFkeSBpbnN0YWxsZWQuIENvbnRpbnVpbmcuYCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbGwgdGhlIHBhY2thZ2UgZnJvbSB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gb2YgdXBncmFkZSBpdCBpZiBhbiBvbGRlclxuICogdmVyc2lvbiBvZiB0aGUgc2FtZSBwYWNrYWdlIGlzIGFscmVhZHkgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBsb2NhbCBwYWNrYWdlLlxuICogQHBhcmFtIHs/c3RyaW5nfSBwa2cgLSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFsbGVkIHBhY2thZ2UuIFRoZSBtZXRob2Qgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgICBwZXJmb3JtIGZhc3RlciBpZiBpdCBpcyBzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCB1bnRpbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbGxhdGlvbiBpcyBjb21wbGV0ZWQuXG4gKiBAdGhyb3dzIHtlcnJvcn0gSWYgYW4gdW5leHBlY3RlZCBlcnJvciBoYXBwZW5zIGR1cmluZyBpbnN0YWxsLlxuICovXG5hcGtVdGlsc01ldGhvZHMuaW5zdGFsbE9yVXBncmFkZSA9IGFzeW5jIGZ1bmN0aW9uIChhcGssIHBrZyA9IG51bGwsIHRpbWVvdXQgPSA2MDAwMCkge1xuICBsZXQgYXBrSW5mbyA9IG51bGw7XG4gIGlmICghcGtnKSB7XG4gICAgYXBrSW5mbyA9IGF3YWl0IHRoaXMuZ2V0QXBrSW5mbyhhcGspO1xuICAgIHBrZyA9IGFwa0luZm8ubmFtZTtcbiAgfVxuICBpZiAoIXBrZykge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgcmVhZCB0aGUgcGFja2FnZSBuYW1lIG9mICR7YXBrfS4gQXNzdW1pbmcgY29ycmVjdCBhcHAgdmVyc2lvbiBpcyBhbHJlYWR5IGluc3RhbGxlZGApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWF3YWl0IHRoaXMuaXNBcHBJbnN0YWxsZWQocGtnKSkge1xuICAgIGF3YWl0IHRoaXMuaW5zdGFsbChhcGssIGZhbHNlLCB0aW1lb3V0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGtnSW5mbyA9IGF3YWl0IHRoaXMuZ2V0UGFja2FnZUluZm8ocGtnKTtcbiAgY29uc3QgcGtnVmVyc2lvbkNvZGUgPSBwa2dJbmZvLnZlcnNpb25Db2RlO1xuICBpZiAoIWFwa0luZm8pIHtcbiAgICBhcGtJbmZvID0gYXdhaXQgdGhpcy5nZXRBcGtJbmZvKGFwayk7XG4gIH1cbiAgY29uc3QgYXBrVmVyc2lvbkNvZGUgPSBhcGtJbmZvLnZlcnNpb25Db2RlO1xuICBpZiAoXy5pc1VuZGVmaW5lZChhcGtWZXJzaW9uQ29kZSkgfHwgXy5pc1VuZGVmaW5lZChwa2dWZXJzaW9uQ29kZSkpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IHJlYWQgdmVyc2lvbiBjb2RlcyBvZiAke2Fwa30gYW5kL29yICR7cGtnfS4gQXNzdW1pbmcgY29ycmVjdCBhcHAgdmVyc2lvbiBpcyBhbHJlYWR5IGluc3RhbGxlZGApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGtnVmVyc2lvbkNvZGUgPj0gYXBrVmVyc2lvbkNvZGUpIHtcbiAgICBsb2cuZGVidWcoYFRoZSBpbnN0YWxsZWQgXCIke3BrZ31cIiBwYWNrYWdlIGRvZXMgbm90IHJlcXVpcmUgdXBncmFkZSAoJHtwa2dWZXJzaW9uQ29kZX0gPj0gJHthcGtWZXJzaW9uQ29kZX0pYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvZy5kZWJ1ZyhgVGhlIGluc3RhbGxlZCBcIiR7cGtnfVwiIHBhY2thZ2UgaXMgb2xkZXIgdGhhbiAke2Fwa30gKCR7cGtnVmVyc2lvbkNvZGV9IDwgJHthcGtWZXJzaW9uQ29kZX0pLiBgICtcbiAgICAgICAgICAgIGBFeGVjdXRpbmcgdXBncmFkZWApO1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuaW5zdGFsbChhcGssIHRydWUsIHRpbWVvdXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IHVwZ3JhZGUgJHtwa2d9IGJlY2F1c2Ugb2YgXCIke2Vyci5tZXNzYWdlfVwiLiBUcnlpbmcgZnVsbCByZWluc3RhbGxgKTtcbiAgICBpZiAoIWF3YWl0IHRoaXMudW5pbnN0YWxsQXBrKHBrZykpIHtcbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGBcIiR7cGtnfVwiIHBhY2thZ2UgY2Fubm90IGJlIHVuaW5zdGFsbGVkYCk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuaW5zdGFsbChhcGssIGZhbHNlLCB0aW1lb3V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeHRyYWN0IHN0cmluZyByZXNvdXJjZXMgZnJvbSB0aGUgZ2l2ZW4gcGFja2FnZSBvbiBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgcGFja2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSAtIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byBleHRyYWN0IHRoZSByZXNvdXJjZXMgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG91dCAtIFRoZSBuYW1lIG9mIHRoZSBkZXN0aW5hdGlvbiBmb2xkZXIgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgdGhlIGV4dHJhY3RlZCBmaWxlIHRvLlxuICogQHJldHVybiB7b2JqZWN0fSBBIG1hcHBpbmcgb2JqZWN0LCB3aGVyZSBwcm9wZXJ0aWVzIGFyZTogJ2Fwa1N0cmluZ3MnLCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgIHBhcnNlZCByZXNvdXJjZSBmaWxlIHJlcHJlc2VudGVkIGFzIEpTT04gb2JqZWN0LCBhbmQgJ2xvY2FsUGF0aCcsXG4gKiAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmcgdGhlIHBhdGggdG8gdGhlIGV4dHJhY3RlZCBmaWxlIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLmV4dHJhY3RTdHJpbmdzRnJvbUFwayA9IGFzeW5jIGZ1bmN0aW9uIChhcGssIGxhbmd1YWdlLCBvdXQpIHtcbiAgbG9nLmRlYnVnKGBFeHRyYWN0aW5nIHN0cmluZ3MgZm9yIGxhbmd1YWdlOiAke2xhbmd1YWdlIHx8IFwiZGVmYXVsdFwifWApO1xuICBsZXQgc3RyaW5nc0pzb24gPSAnc3RyaW5ncy5qc29uJztcbiAgbGV0IGxvY2FsUGF0aDtcbiAgaWYgKCFsYW5ndWFnZSkge1xuICAgIGxhbmd1YWdlID0gYXdhaXQgdGhpcy5nZXREZXZpY2VMYW5ndWFnZSgpO1xuICB9XG4gIGxldCBhcGtUb29scyA9IHRoaXMuamFyc1snYXBwaXVtX2Fwa190b29scy5qYXInXTtcbiAgbGV0IGFyZ3MgPSBbJy1qYXInLCBhcGtUb29scywgJ3N0cmluZ3NGcm9tQXBrJywgYXBrLCBvdXQsIGxhbmd1YWdlXTtcbiAgbGV0IGZpbGVEYXRhLCBhcGtTdHJpbmdzO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoJ2phdmEnLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgTm8gc3RyaW5ncy54bWwgZm9yIGxhbmd1YWdlICcke2xhbmd1YWdlfScsIGdldHRpbmcgZGVmYXVsdCBgICtcbiAgICAgICAgICAgICAgYHN0cmluZ3MueG1sYCk7XG4gICAgYXJncy5wb3AoKTtcbiAgICBhd2FpdCBleGVjKCdqYXZhJywgYXJncyk7XG4gIH1cblxuICB0cnkge1xuICAgIGxvZy5kZWJ1ZyhcIlJlYWRpbmcgc3RyaW5ncyBmcm9tIGNvbnZlcnRlZCBzdHJpbmdzLmpzb25cIik7XG4gICAgbG9jYWxQYXRoID0gcGF0aC5qb2luKG91dCwgc3RyaW5nc0pzb24pO1xuICAgIGZpbGVEYXRhID0gYXdhaXQgZnMucmVhZEZpbGUobG9jYWxQYXRoLCAndXRmOCcpO1xuICAgIGFwa1N0cmluZ3MgPSBKU09OLnBhcnNlKGZpbGVEYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChmaWxlRGF0YSkge1xuICAgICAgbG9nLmRlYnVnKGBDb250ZW50IHN0YXJ0ZWQgd2l0aDogJHtmaWxlRGF0YS5zbGljZSgwLCAzMDApfWApO1xuICAgIH1cbiAgICBsZXQgbXNnID0gYENvdWxkIG5vdCBwYXJzZSBzdHJpbmdzIGZyb20gc3RyaW5ncy5qc29uLiBPcmlnaW5hbCBgICtcbiAgICAgICAgICAgICAgYGVycm9yOiAke2UubWVzc2FnZX1gO1xuICAgIGxvZy5lcnJvckFuZFRocm93KG1zZyk7XG4gIH1cbiAgcmV0dXJuIHthcGtTdHJpbmdzLCBsb2NhbFBhdGh9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhbmd1YWdlIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb2YgZGV2aWNlIGxhbmd1YWdlLlxuICovXG5hcGtVdGlsc01ldGhvZHMuZ2V0RGV2aWNlTGFuZ3VhZ2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxldCBsYW5ndWFnZTtcbiAgaWYgKGF3YWl0IHRoaXMuZ2V0QXBpTGV2ZWwoKSA8IDIzKSB7XG4gICAgbGFuZ3VhZ2UgPSBhd2FpdCB0aGlzLmdldERldmljZVN5c0xhbmd1YWdlKCk7XG4gICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgbGFuZ3VhZ2UgPSBhd2FpdCB0aGlzLmdldERldmljZVByb2R1Y3RMYW5ndWFnZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYW5ndWFnZSA9IChhd2FpdCB0aGlzLmdldERldmljZUxvY2FsZSgpKS5zcGxpdChcIi1cIilbMF07XG4gIH1cbiAgcmV0dXJuIGxhbmd1YWdlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxhbmd1YWdlIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSAtIFRoZSBuYW1lIG9mIHRoZSBuZXcgZGV2aWNlIGxhbmd1YWdlLlxuICovXG5hcGtVdGlsc01ldGhvZHMuc2V0RGV2aWNlTGFuZ3VhZ2UgPSBhc3luYyBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgLy8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGluIEFQSSA8IDIzXG4gIGF3YWl0IHRoaXMuc2V0RGV2aWNlU3lzTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvdW50cnkgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiBkZXZpY2UgY291bnRyeS5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLmdldERldmljZUNvdW50cnkgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBpbiBBUEkgPCAyM1xuICBsZXQgY291bnRyeSA9IGF3YWl0IHRoaXMuZ2V0RGV2aWNlU3lzQ291bnRyeSgpO1xuICBpZiAoIWNvdW50cnkpIHtcbiAgICBjb3VudHJ5ID0gYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9kdWN0Q291bnRyeSgpO1xuICB9XG4gIHJldHVybiBjb3VudHJ5O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvdW50cnkgbmFtZSBvZiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvdW50cnkgLSBUaGUgbmFtZSBvZiB0aGUgbmV3IGRldmljZSBjb3VudHJ5LlxuICovXG5hcGtVdGlsc01ldGhvZHMuc2V0RGV2aWNlQ291bnRyeSA9IGFzeW5jIGZ1bmN0aW9uIChjb3VudHJ5KSB7XG4gIC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBpbiBBUEkgPCAyM1xuICBhd2FpdCB0aGlzLnNldERldmljZVN5c0NvdW50cnkoY291bnRyeSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbG9jYWxlIG5hbWUgb2YgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb2YgZGV2aWNlIGxvY2FsZS5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLmdldERldmljZUxvY2FsZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGluIEFQSSA+PSAyM1xuICBsZXQgbG9jYWxlID0gYXdhaXQgdGhpcy5nZXREZXZpY2VTeXNMb2NhbGUoKTtcbiAgaWYgKCFsb2NhbGUpIHtcbiAgICBsb2NhbGUgPSBhd2FpdCB0aGlzLmdldERldmljZVByb2R1Y3RMb2NhbGUoKTtcbiAgfVxuICByZXR1cm4gbG9jYWxlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxvY2FsZSBuYW1lIG9mIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlIC0gVGhlIG5hbWUgb2YgdGhlIG5ldyBkZXZpY2UgY291bnRyeS5cbiAqL1xuYXBrVXRpbHNNZXRob2RzLnNldERldmljZUxvY2FsZSA9IGFzeW5jIGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgLy8gdGhpcyBtZXRob2QgaXMgb25seSB1c2VkIGluIEFQSSA+PSAyM1xuICBhd2FpdCB0aGlzLnNldERldmljZVN5c0xvY2FsZShsb2NhbGUpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHBhY2thZ2UgbmFtZSBmcm9tIGxvY2FsIGFwayBmaWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIGV4aXN0aW5nIC5hcGsgcGFja2FnZSBvbiB0aGUgbG9jYWxcbiAqICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHBhcnNlZCBwYWNrYWdlIG5hbWUgb3IgX251bGxfIGlmIGl0IGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5nZXRQYWNrYWdlTmFtZSA9IGFzeW5jIGZ1bmN0aW9uIChhcGspIHtcbiAgbGV0IGFyZ3MgPSBbJ2R1bXAnLCAnYmFkZ2luZycsIGFwa107XG4gIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQsIGFyZ3MpO1xuICBsZXQgYXBrUGFja2FnZSA9IG5ldyBSZWdFeHAoL3BhY2thZ2U6IG5hbWU9JyhbXiddKyknL2cpLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKGFwa1BhY2thZ2UgJiYgYXBrUGFja2FnZS5sZW5ndGggPj0gMikge1xuICAgIGFwa1BhY2thZ2UgPSBhcGtQYWNrYWdlWzFdO1xuICB9IGVsc2Uge1xuICAgIGFwa1BhY2thZ2UgPSBudWxsO1xuICB9XG4gIHJldHVybiBhcGtQYWNrYWdlO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqY2V0fSBBcHBJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFBhY2thZ2UgbmFtZSwgZm9yIGV4YW1wbGUgJ2NvbS5hY21lLmFwcCcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbkNvZGUgLSBWZXJzaW9uIGNvZGUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvbk5hbWUgLSBWZXJzaW9uIG5hbWUsIGZvciBleGFtcGxlICcxLjAnLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBwYWNrYWdlIGluZm8gZnJvbSBsb2NhbCBhcGsgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrUGF0aCAtIFRoZSBmdWxsIHBhdGggdG8gZXhpc3RpbmcgLmFwayBwYWNrYWdlIG9uIHRoZSBsb2NhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHN5c3RlbS5cbiAqIEByZXR1cm4gez9BcHBJbmZvfSBUaGUgcGFyc2VkIGFwcGxpY2F0aW9uIGluZm9ybWF0aW9uLlxuICovXG5hcGtVdGlsc01ldGhvZHMuZ2V0QXBrSW5mbyA9IGFzeW5jIGZ1bmN0aW9uIChhcGtQYXRoKSB7XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKGFwa1BhdGgpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSBmaWxlIGF0IHBhdGggJHthcGtQYXRofSBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYWNjZXNzaWJsZWApO1xuICB9XG4gIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy5hYXB0LCBbJ2QnLCAnYmFkZ2luZycsIGFwa1BhdGhdKTtcbiAgICBjb25zdCBtYXRjaGVzID0gbmV3IFJlZ0V4cCgvcGFja2FnZTogbmFtZT0nKFteJ10rKScgdmVyc2lvbkNvZGU9JyhcXGQrKScgdmVyc2lvbk5hbWU9JyhbXiddKyknLykuZXhlYyhzdGRvdXQpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBtYXRjaGVzWzFdLFxuICAgICAgICB2ZXJzaW9uQ29kZTogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApLFxuICAgICAgICB2ZXJzaW9uTmFtZTogbWF0Y2hlc1szXVxuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBFcnJvciBcIiR7ZXJyLm1lc3NhZ2V9XCIgd2hpbGUgZ2V0dGluZyBiYWRnaW5nIGluZm9gKTtcbiAgfVxuICByZXR1cm4ge307XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcGFja2FnZSBpbmZvIGZyb20gdGhlIGluc3RhbGxlZCBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGtnIC0gVGhlIG5hbWUgb2YgdGhlIGluc3RhbGxlZCBwYWNrYWdlLlxuICogQHJldHVybiB7P0FwcEluZm99IFRoZSBwYXJzZWQgYXBwbGljYXRpb24gaW5mb3JtYXRpb24uXG4gKi9cbmFwa1V0aWxzTWV0aG9kcy5nZXRQYWNrYWdlSW5mbyA9IGFzeW5jIGZ1bmN0aW9uIChwa2cpIHtcbiAgbG9nLmRlYnVnKGBHZXR0aW5nIHBhY2thZ2UgaW5mbyBmb3IgJHtwa2d9YCk7XG4gIGxldCByZXN1bHQgPSB7bmFtZTogcGtnfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKFsnZHVtcHN5cycsICdwYWNrYWdlJywgcGtnXSk7XG4gICAgY29uc3QgdmVyc2lvbk5hbWVNYXRjaCA9IG5ldyBSZWdFeHAoL3ZlcnNpb25OYW1lPShbXFxkK1xcLl0rKS8pLmV4ZWMoc3Rkb3V0KTtcbiAgICBpZiAodmVyc2lvbk5hbWVNYXRjaCkge1xuICAgICAgcmVzdWx0LnZlcnNpb25OYW1lID0gdmVyc2lvbk5hbWVNYXRjaFsxXTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbkNvZGVNYXRjaCA9IG5ldyBSZWdFeHAoL3ZlcnNpb25Db2RlPShcXGQrKS8pLmV4ZWMoc3Rkb3V0KTtcbiAgICBpZiAodmVyc2lvbkNvZGVNYXRjaCkge1xuICAgICAgcmVzdWx0LnZlcnNpb25Db2RlID0gcGFyc2VJbnQodmVyc2lvbkNvZGVNYXRjaFsxXSwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgRXJyb3IgXCIke2Vyci5tZXNzYWdlfVwiIHdoaWxlIGR1bXBpbmcgcGFja2FnZSBpbmZvYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFwa1V0aWxzTWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
