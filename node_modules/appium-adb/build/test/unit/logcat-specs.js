'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard')['default'];

var _this2 = this;

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _chaiAsPromised = require('chai-as-promised');

var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);

var _teen_process = require('teen_process');

var teen_process = _interopRequireWildcard(_teen_process);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _libLogcat = require('../../lib/logcat');

var _libLogcat2 = _interopRequireDefault(_libLogcat);

var _appiumTestSupport = require('appium-test-support');

_chai2['default'].use(_chaiAsPromised2['default']);

describe('logcat', function callee$0$0() {
  var adb, logcat;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        adb = { path: 'dummyPath', defaultArgs: [] };
        logcat = new _libLogcat2['default']({ adb: adb, debug: false, debugTrace: false });

        describe('startCapture', (0, _appiumTestSupport.withMocks)({ teen_process: teen_process }, function (mocks) {
          it('should correctly call subprocess and should resolve promise', function callee$2$0() {
            var conn, logs;
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  conn = new _events2['default'].EventEmitter();

                  conn.start = function () {};
                  mocks.teen_process.expects("SubProcess").once().withExactArgs('dummyPath', ['logcat', '-v', 'threadtime']).returns(conn);
                  setTimeout(function () {
                    conn.emit('lines-stdout', ['- beginning of system\r']);
                  }, 0);
                  context$3$0.next = 6;
                  return _regeneratorRuntime.awrap(logcat.startCapture());

                case 6:
                  logs = logcat.getLogs();

                  logs.should.have.length.above(0);
                  mocks.teen_process.verify();

                case 9:
                case 'end':
                  return context$3$0.stop();
              }
            }, null, _this);
          });
          it('should correctly call subprocess and should reject promise', function callee$2$0() {
            var conn;
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  conn = new _events2['default'].EventEmitter();

                  conn.start = function () {};
                  mocks.teen_process.expects("SubProcess").once().withExactArgs('dummyPath', ['logcat', '-v', 'threadtime']).returns(conn);
                  setTimeout(function () {
                    conn.emit('lines-stderr', ['execvp()']);
                  }, 0);
                  context$3$0.next = 6;
                  return _regeneratorRuntime.awrap(logcat.startCapture().should.eventually.be.rejectedWith('Logcat'));

                case 6:
                  mocks.teen_process.verify();

                case 7:
                case 'end':
                  return context$3$0.stop();
              }
            }, null, _this);
          });
          it('should correctly call subprocess and should resolve promise if it fails on startup', function callee$2$0() {
            var conn;
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  conn = new _events2['default'].EventEmitter();

                  conn.start = function () {};
                  mocks.teen_process.expects("SubProcess").once().withExactArgs('dummyPath', ['logcat', '-v', 'threadtime']).returns(conn);
                  setTimeout(function () {
                    conn.emit('lines-stderr', ['something']);
                  }, 0);
                  context$3$0.next = 6;
                  return _regeneratorRuntime.awrap(logcat.startCapture().should.eventually.not.be.rejectedWith('Logcat'));

                case 6:
                  mocks.teen_process.verify();

                case 7:
                case 'end':
                  return context$3$0.stop();
              }
            }, null, _this);
          });
        }));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, _this2);
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvdW5pdC9sb2djYXQtc3BlY3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztvQkFBaUIsTUFBTTs7Ozs4QkFDSSxrQkFBa0I7Ozs7NEJBQ2YsY0FBYzs7SUFBaEMsWUFBWTs7c0JBQ0wsUUFBUTs7Ozt5QkFDUixrQkFBa0I7Ozs7aUNBQ1gscUJBQXFCOztBQUcvQyxrQkFBSyxHQUFHLDZCQUFnQixDQUFDOztBQUV6QixRQUFRLENBQUMsUUFBUSxFQUFFO01BQ2IsR0FBRyxFQUNILE1BQU07Ozs7OztBQUROLFdBQUcsR0FBRyxFQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBQztBQUMxQyxjQUFNLEdBQUcsMkJBQVcsRUFBQyxHQUFHLEVBQUgsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBQyxDQUFDOztBQUMvRCxnQkFBUSxDQUFDLGNBQWMsRUFBRSxrQ0FBVSxFQUFDLFlBQVksRUFBWixZQUFZLEVBQUMsRUFBRSxVQUFDLEtBQUssRUFBSztBQUM1RCxZQUFFLENBQUMsNkRBQTZELEVBQUU7Z0JBQzVELElBQUksRUFTSixJQUFJOzs7O0FBVEosc0JBQUksR0FBRyxJQUFJLG9CQUFPLFlBQVksRUFBRTs7QUFDcEMsc0JBQUksQ0FBQyxLQUFLLEdBQUcsWUFBTSxFQUFHLENBQUM7QUFDdkIsdUJBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUNyQyxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUNqRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakIsNEJBQVUsQ0FBQyxZQUFZO0FBQ3JCLHdCQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLHlCQUF5QixDQUFDLENBQUMsQ0FBQzttQkFDeEQsRUFBRSxDQUFDLENBQUMsQ0FBQzs7bURBQ0EsTUFBTSxDQUFDLFlBQVksRUFBRTs7O0FBQ3ZCLHNCQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRTs7QUFDM0Isc0JBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakMsdUJBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7Ozs7Ozs7V0FDN0IsQ0FBQyxDQUFDO0FBQ0gsWUFBRSxDQUFDLDREQUE0RCxFQUFFO2dCQUMzRCxJQUFJOzs7O0FBQUosc0JBQUksR0FBRyxJQUFJLG9CQUFPLFlBQVksRUFBRTs7QUFDcEMsc0JBQUksQ0FBQyxLQUFLLEdBQUcsWUFBTSxFQUFHLENBQUM7QUFDdkIsdUJBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUNyQyxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUNqRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakIsNEJBQVUsQ0FBQyxZQUFZO0FBQ3JCLHdCQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7bUJBQ3pDLEVBQUUsQ0FBQyxDQUFDLENBQUM7O21EQUNBLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDOzs7QUFDdkUsdUJBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7Ozs7Ozs7V0FDN0IsQ0FBQyxDQUFDO0FBQ0gsWUFBRSxDQUFDLG9GQUFvRixFQUFFO2dCQUNuRixJQUFJOzs7O0FBQUosc0JBQUksR0FBRyxJQUFJLG9CQUFPLFlBQVksRUFBRTs7QUFDcEMsc0JBQUksQ0FBQyxLQUFLLEdBQUcsWUFBTSxFQUFHLENBQUM7QUFDdkIsdUJBQUssQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUNyQyxJQUFJLEVBQUUsQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUNqRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakIsNEJBQVUsQ0FBQyxZQUFZO0FBQ3JCLHdCQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7bUJBQzFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7O21EQUNBLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQzs7O0FBQzNFLHVCQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDOzs7Ozs7O1dBQzdCLENBQUMsQ0FBQztTQUNKLENBQUMsQ0FBQyxDQUFDOzs7Ozs7O0NBQ0wsQ0FBQyxDQUFDIiwiZmlsZSI6InRlc3QvdW5pdC9sb2djYXQtc3BlY3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hhaSBmcm9tICdjaGFpJztcbmltcG9ydCBjaGFpQXNQcm9taXNlZCBmcm9tICdjaGFpLWFzLXByb21pc2VkJztcbmltcG9ydCAqIGFzIHRlZW5fcHJvY2VzcyBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IExvZ2NhdCBmcm9tICcuLi8uLi9saWIvbG9nY2F0JztcbmltcG9ydCB7IHdpdGhNb2NrcyB9IGZyb20gJ2FwcGl1bS10ZXN0LXN1cHBvcnQnO1xuXG5cbmNoYWkudXNlKGNoYWlBc1Byb21pc2VkKTtcblxuZGVzY3JpYmUoJ2xvZ2NhdCcsIGFzeW5jICgpID0+IHtcbiAgbGV0IGFkYiA9IHtwYXRoOiAnZHVtbXlQYXRoJywgZGVmYXVsdEFyZ3M6IFtdfTtcbiAgbGV0IGxvZ2NhdCA9IG5ldyBMb2djYXQoe2FkYiwgZGVidWc6IGZhbHNlLCBkZWJ1Z1RyYWNlOiBmYWxzZX0pO1xuICBkZXNjcmliZSgnc3RhcnRDYXB0dXJlJywgd2l0aE1vY2tzKHt0ZWVuX3Byb2Nlc3N9LCAobW9ja3MpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNvcnJlY3RseSBjYWxsIHN1YnByb2Nlc3MgYW5kIHNob3VsZCByZXNvbHZlIHByb21pc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY29ubiA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgICBjb25uLnN0YXJ0ID0gKCkgPT4geyB9O1xuICAgICAgbW9ja3MudGVlbl9wcm9jZXNzLmV4cGVjdHMoXCJTdWJQcm9jZXNzXCIpXG4gICAgICAgIC5vbmNlKCkud2l0aEV4YWN0QXJncygnZHVtbXlQYXRoJywgWydsb2djYXQnLCAnLXYnLCAndGhyZWFkdGltZSddKVxuICAgICAgICAucmV0dXJucyhjb25uKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25uLmVtaXQoJ2xpbmVzLXN0ZG91dCcsIFsnLSBiZWdpbm5pbmcgb2Ygc3lzdGVtXFxyJ10pO1xuICAgICAgfSwgMCk7XG4gICAgICBhd2FpdCBsb2djYXQuc3RhcnRDYXB0dXJlKCk7XG4gICAgICBsZXQgbG9ncyA9IGxvZ2NhdC5nZXRMb2dzKCk7XG4gICAgICBsb2dzLnNob3VsZC5oYXZlLmxlbmd0aC5hYm92ZSgwKTtcbiAgICAgIG1vY2tzLnRlZW5fcHJvY2Vzcy52ZXJpZnkoKTtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIGNvcnJlY3RseSBjYWxsIHN1YnByb2Nlc3MgYW5kIHNob3VsZCByZWplY3QgcHJvbWlzZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBjb25uID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgICAgIGNvbm4uc3RhcnQgPSAoKSA9PiB7IH07XG4gICAgICBtb2Nrcy50ZWVuX3Byb2Nlc3MuZXhwZWN0cyhcIlN1YlByb2Nlc3NcIilcbiAgICAgICAgLm9uY2UoKS53aXRoRXhhY3RBcmdzKCdkdW1teVBhdGgnLCBbJ2xvZ2NhdCcsICctdicsICd0aHJlYWR0aW1lJ10pXG4gICAgICAgIC5yZXR1cm5zKGNvbm4pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbm4uZW1pdCgnbGluZXMtc3RkZXJyJywgWydleGVjdnAoKSddKTtcbiAgICAgIH0sIDApO1xuICAgICAgYXdhaXQgbG9nY2F0LnN0YXJ0Q2FwdHVyZSgpLnNob3VsZC5ldmVudHVhbGx5LmJlLnJlamVjdGVkV2l0aCgnTG9nY2F0Jyk7XG4gICAgICBtb2Nrcy50ZWVuX3Byb2Nlc3MudmVyaWZ5KCk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBjb3JyZWN0bHkgY2FsbCBzdWJwcm9jZXNzIGFuZCBzaG91bGQgcmVzb2x2ZSBwcm9taXNlIGlmIGl0IGZhaWxzIG9uIHN0YXJ0dXAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgY29ubiA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgICBjb25uLnN0YXJ0ID0gKCkgPT4geyB9O1xuICAgICAgbW9ja3MudGVlbl9wcm9jZXNzLmV4cGVjdHMoXCJTdWJQcm9jZXNzXCIpXG4gICAgICAgIC5vbmNlKCkud2l0aEV4YWN0QXJncygnZHVtbXlQYXRoJywgWydsb2djYXQnLCAnLXYnLCAndGhyZWFkdGltZSddKVxuICAgICAgICAucmV0dXJucyhjb25uKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25uLmVtaXQoJ2xpbmVzLXN0ZGVycicsIFsnc29tZXRoaW5nJ10pO1xuICAgICAgfSwgMCk7XG4gICAgICBhd2FpdCBsb2djYXQuc3RhcnRDYXB0dXJlKCkuc2hvdWxkLmV2ZW50dWFsbHkubm90LmJlLnJlamVjdGVkV2l0aCgnTG9nY2F0Jyk7XG4gICAgICBtb2Nrcy50ZWVuX3Byb2Nlc3MudmVyaWZ5KCk7XG4gICAgfSk7XG4gIH0pKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
