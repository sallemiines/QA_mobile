"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DEFAULT_ADB_EXEC_TIMEOUT", {
  enumerable: true,
  get: function () {
    return _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  }
});
exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

let systemCallMethods = {};
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';

systemCallMethods.getSdkBinaryPath = async function getSdkBinaryPath(binaryName) {
  if (this.sdkRoot) {
    return await this.getBinaryFromSdkRoot(binaryName);
  }

  _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

  return await this.getBinaryFromPath(binaryName);
};

systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function getBinaryNameForOS(binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].includes(binaryName)) {
    return `${binaryName}.bat`;
  }

  if (!_path.default.extname(binaryName)) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});

systemCallMethods.getBinaryFromSdkRoot = async function getBinaryFromSdkRoot(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }

  const fullBinaryName = this.getBinaryNameForOS(binaryName);
  const binaryLocs = ['platform-tools', 'emulator', 'tools', `tools${_path.default.sep}bin`].map(x => _path.default.resolve(this.sdkRoot, x, fullBinaryName));
  let buildToolsDirs = await (0, _helpers.getBuildToolsDirs)(this.sdkRoot);

  if (this.buildToolsVersion) {
    buildToolsDirs = buildToolsDirs.filter(x => _path.default.basename(x) === this.buildToolsVersion);

    if (_lodash.default.isEmpty(buildToolsDirs)) {
      _logger.default.info(`Found no build tools whose version matches to '${this.buildToolsVersion}'`);
    } else {
      _logger.default.info(`Using build tools at '${buildToolsDirs}'`);
    }
  }

  binaryLocs.push(...buildToolsDirs.map(dir => _path.default.resolve(dir, fullBinaryName)));
  let binaryLoc = null;

  for (const loc of binaryLocs) {
    if (await _appiumSupport.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` + `Do you have Android Build Tools ${this.buildToolsVersion ? `v ${this.buildToolsVersion} ` : ''}` + `installed at '${this.sdkRoot}'?`);
  }

  _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);

  this.binaries[binaryName] = binaryLoc;
  return binaryLoc;
};

systemCallMethods.getBinaryFromPath = async function getBinaryFromPath(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }

  const fullBinaryName = this.getBinaryNameForOS(binaryName);

  try {
    const binaryLoc = await _appiumSupport.fs.which(fullBinaryName);

    _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);

    this.binaries[binaryName] = binaryLoc;
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find '${fullBinaryName}' in PATH. Please set the ANDROID_HOME ` + `or ANDROID_SDK_ROOT environment variables to the correct Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function getConnectedDevices() {
  _logger.default.debug('Getting connected devices...');

  let stdout;

  try {
    ({
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'devices']));
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }

  const listHeader = 'List of devices';
  const startingIndex = stdout.indexOf(listHeader);

  if (startingIndex < 0) {
    throw new Error(`Unexpected output while trying to get devices: ${stdout}`);
  }

  stdout = stdout.slice(startingIndex);
  const excludedLines = [listHeader, 'adb server', '* daemon', 'offline'];
  const devices = stdout.split('\n').map(_lodash.default.trim).filter(line => line && !excludedLines.some(x => line.includes(x))).reduce((acc, line) => {
    const [udid, state] = line.split(/\s+/);
    acc.push({
      udid,
      state
    });
    return acc;
  }, []);

  if (_lodash.default.isEmpty(devices)) {
    _logger.default.debug('No connected devices have been detected');
  } else {
    _logger.default.debug(`Connected devices: ${JSON.stringify(devices)}`);
  }

  return devices;
};

systemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry(timeoutMs = 20000) {
  let start = Date.now();

  _logger.default.debug('Trying to find a connected android device');

  let getDevices = async () => {
    if (Date.now() - start > timeoutMs) {
      throw new Error('Could not find a connected Android device.');
    }

    try {
      let devices = await this.getConnectedDevices();

      if (devices.length < 1) {
        _logger.default.debug('Could not find devices, restarting adb server...');

        await this.restartAdb();
        await (0, _asyncbox.sleep)(200);
        return await getDevices();
      }

      return devices;
    } catch (e) {
      _logger.default.debug('Could not find devices, restarting adb server...');

      await this.restartAdb();
      await (0, _asyncbox.sleep)(200);
      return await getDevices();
    }
  };

  return await getDevices();
};

systemCallMethods.restartAdb = async function restartAdb() {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
  } catch (e) {
    _logger.default.error(`Error killing ADB server, going to see if it's online anyway`);
  }
};

systemCallMethods.killServer = async function killServer() {
  _logger.default.debug(`Killing adb server on port ${this.adbPort}`);

  await this.adbExec(['kill-server'], {
    exclusive: true
  });
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function resetTelnetAuthToken() {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function adbExecEmu(cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

let isExecLocked = false;

systemCallMethods.adbExec = async function adbExec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }

  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.adbExecTimeout || _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout';
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;

  const execFunc = async () => {
    try {
      const args = [...this.executable.defaultArgs, ...cmd];

      _logger.default.debug(`Running '${this.executable.path} ${(0, _shellQuote.quote)(args)}'`);

      let {
        stdout
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
      const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
      const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

      if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();

        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }

      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }

      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`;
      }

      throw e;
    }
  };

  if (isExecLocked) {
    _logger.default.debug('Waiting until the other exclusive ADB command is completed');

    await (0, _asyncbox.waitForCondition)(() => !isExecLocked, {
      waitMs: Number.MAX_SAFE_INTEGER,
      intervalMs: 10
    });

    _logger.default.debug('Continuing with the current ADB command');
  }

  if (opts.exclusive) {
    isExecLocked = true;
  }

  try {
    return await execFunc();
  } finally {
    if (opts.exclusive) {
      isExecLocked = false;
    }
  }
};

systemCallMethods.shell = async function shell(cmd, opts = {}) {
  const {
    privileged,
    keepPrivileged
  } = opts;
  let shouldRestoreUser = false;

  if (privileged) {
    _logger.default.info(`'adb shell ${cmd}' requires root access. Attempting to gain root access now.`);

    const {
      wasAlreadyRooted,
      isSuccessful
    } = await this.root();
    shouldRestoreUser = !wasAlreadyRooted;

    if (wasAlreadyRooted) {
      _logger.default.info('Device already had root access');
    } else {
      _logger.default.info(isSuccessful ? 'Root access successfully gained' : 'Could not gain root access');
    }
  }

  let didCommandFail = false;

  try {
    try {
      return await this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
    } catch (err) {
      didCommandFail = true;
      throw err;
    }
  } finally {
    if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
      const {
        isSuccessful
      } = await this.unroot();

      _logger.default.debug(isSuccessful ? 'Returned device to unrooted state' : 'Could not return device to unrooted state');
    }
  }
};

systemCallMethods.createSubProcess = function createSubProcess(args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function getAdbServerPort() {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function getEmulatorPort() {
  _logger.default.debug('Getting running emulator port');

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString(emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function getConnectedEmulators() {
  _logger.default.debug('Getting connected emulators');

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${emulators.length} emulator(s) connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function setEmulatorPort(emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function setDeviceId(deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function setDevice(deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function getRunningAVD(avdName) {
  _logger.default.debug(`Trying to find '${avdName}' emulator`);

  try {
    const emulators = await this.getConnectedEmulators();

    for (const emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      const runningAVDName = await this.sendTelnetCommand('avd name');

      if (_lodash.default.toLower(avdName) === _lodash.default.toLower(runningAVDName)) {
        _logger.default.debug(`Found emulator '${avdName}' on port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator '${avdName}' not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry(avdName, timeoutMs = 20000) {
  let runningAvd;

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        runningAvd = await this.getRunningAVD(avdName.replace('@', ''));
        return runningAvd;
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }

  return runningAvd;
};

systemCallMethods.killAllEmulators = async function killAllEmulators() {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function killEmulator(avdName = null, timeout = 60000) {
  if (_appiumSupport.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _appiumSupport.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function launchAVD(avdName, avdArgs, language, country, avdLaunchTimeout = 60000, avdReadyTimeout = 60000, retryTimes = 1) {
  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${avdLaunchTimeout}ms and readyTimeout ${avdReadyTimeout}ms`);

  let emulatorBinaryPath = await this.getSdkBinaryPath('emulator');

  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  let launchArgs = ['-avd', avdName];

  if (_lodash.default.isString(language)) {
    _logger.default.debug(`Setting Android Device Language to ${language}`);

    launchArgs.push('-prop', `persist.sys.language=${language.toLowerCase()}`);
  }

  if (_lodash.default.isString(country)) {
    _logger.default.debug(`Setting Android Device Country to ${country}`);

    launchArgs.push('-prop', `persist.sys.country=${country.toUpperCase()}`);
  }

  let locale;

  if (_lodash.default.isString(language) && _lodash.default.isString(country)) {
    locale = language.toLowerCase() + '-' + country.toUpperCase();
  } else if (_lodash.default.isString(language)) {
    locale = language.toLowerCase();
  } else if (_lodash.default.isString(country)) {
    locale = country;
  }

  if (_lodash.default.isString(locale)) {
    _logger.default.debug(`Setting Android Device Locale to ${locale}`);

    launchArgs.push('-prop', `persist.sys.locale=${locale}`);
  }

  if (!_lodash.default.isEmpty(avdArgs)) {
    launchArgs.push(...(_lodash.default.isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${JSON.stringify(launchArgs)}`);

  let proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, avdLaunchTimeout));
  await this.waitForEmulatorReady(avdReadyTimeout);
  return proc;
};

systemCallMethods.getAdbVersion = _lodash.default.memoize(async function getAdbVersion() {
  try {
    let adbVersion = (await this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, '$1');
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
});

systemCallMethods.checkAvdExist = async function checkAvdExist(avdName) {
  let cmd, result;

  try {
    cmd = await this.getSdkBinaryPath('emulator');
    result = await (0, _teen_process.exec)(cmd, ['-list-avds']);
  } catch (e) {
    let unknownOptionError = new RegExp('unknown option: -list-avds', 'i').test(e.stderr);

    if (!unknownOptionError) {
      throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }

    const sdkVersion = await (0, _helpers.getSdkToolsVersion)();
    let binaryName = 'android';

    if (sdkVersion) {
      if (sdkVersion.major >= 25) {
        binaryName = 'avdmanager';
      }
    } else {
      _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
    }

    cmd = await this.getSdkBinaryPath(binaryName);
    result = await (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
  }

  if (result.stdout.indexOf(avdName) === -1) {
    let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
    throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
  }
};

systemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady(timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test((await this.shell(['pm', 'get-install-location'])));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function waitForDevice(appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      await this.restartAdb();
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function reboot(retries = DEFAULT_ADB_REBOOT_RETRIES) {
  const {
    wasAlreadyRooted
  } = await this.root();

  try {
    await this.shell(['stop']);
    await _bluebird.default.delay(2000);
    await this.setDeviceProperty('sys.boot_completed', 0, {
      privileged: false
    });
    await this.shell(['start']);
  } catch (e) {
    const {
      message
    } = e;

    if (message.includes('must be root')) {
      throw new Error(`Could not reboot device. Rebooting requires root access and ` + `attempt to get root access on device failed with error: '${message}'`);
    }

    throw e;
  } finally {
    if (!wasAlreadyRooted) {
      await this.unroot();
    }
  }

  const started = process.hrtime();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${process.hrtime(started)[0]}s`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.changeUserPrivileges = async function changeUserPrivileges(isElevated) {
  const cmd = isElevated ? 'root' : 'unroot';
  const isRoot = await this.isRoot();

  if (isRoot && isElevated || !isRoot && !isElevated) {
    return {
      isSuccessful: true,
      wasAlreadyRooted: isRoot
    };
  }

  let wasAlreadyRooted = isRoot;

  try {
    let {
      stdout
    } = await this.adbExec([cmd]);

    if (stdout) {
      if (stdout.includes('adbd cannot run as root')) {
        return {
          isSuccessful: false,
          wasAlreadyRooted
        };
      }

      if (stdout.includes('already running as root')) {
        wasAlreadyRooted = true;
      }
    }

    return {
      isSuccessful: true,
      wasAlreadyRooted
    };
  } catch (err) {
    const {
      stderr = '',
      message
    } = err;

    _logger.default.warn(`Unable to ${cmd} adb daemon. Original error: '${message}'. Stderr: '${stderr}'. Continuing.`);

    if (['closed', 'device offline', 'timeout expired'].some(x => stderr.toLowerCase().includes(x))) {
      _logger.default.warn(`Attempt to 'adb ${cmd}' caused device to go offline. Restarting adb.`);

      await this.restartAdb();
    }

    return {
      isSuccessful: false,
      wasAlreadyRooted
    };
  }
};

systemCallMethods.root = async function root() {
  return await this.changeUserPrivileges(true);
};

systemCallMethods.unroot = async function unroot() {
  return await this.changeUserPrivileges(false);
};

systemCallMethods.isRoot = async function isRoot() {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function fileExists(remotePath) {
  let files = await this.ls(remotePath);
  return files.length > 0;
};

systemCallMethods.ls = async function ls(remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function fileSize(remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function installMitmCertificate(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _appiumSupport.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJiaW5hcnlOYW1lIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290IiwibG9nIiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiXyIsIm1lbW9pemUiLCJzeXN0ZW0iLCJpc1dpbmRvd3MiLCJpbmNsdWRlcyIsInBhdGgiLCJleHRuYW1lIiwiYmluYXJpZXMiLCJmdWxsQmluYXJ5TmFtZSIsImJpbmFyeUxvY3MiLCJzZXAiLCJtYXAiLCJ4IiwicmVzb2x2ZSIsImJ1aWxkVG9vbHNEaXJzIiwiYnVpbGRUb29sc1ZlcnNpb24iLCJmaWx0ZXIiLCJiYXNlbmFtZSIsImlzRW1wdHkiLCJpbmZvIiwicHVzaCIsImRpciIsImJpbmFyeUxvYyIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwid2hpY2giLCJlIiwiZ2V0Q29ubmVjdGVkRGV2aWNlcyIsImRlYnVnIiwic3Rkb3V0IiwiZXhlY3V0YWJsZSIsImRlZmF1bHRBcmdzIiwibWVzc2FnZSIsImxpc3RIZWFkZXIiLCJzdGFydGluZ0luZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwiZXhjbHVkZWRMaW5lcyIsImRldmljZXMiLCJzcGxpdCIsInRyaW0iLCJsaW5lIiwic29tZSIsInJlZHVjZSIsImFjYyIsInVkaWQiLCJzdGF0ZSIsImdldERldmljZXNXaXRoUmV0cnkiLCJ0aW1lb3V0TXMiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJnZXREZXZpY2VzIiwibGVuZ3RoIiwicmVzdGFydEFkYiIsInN1cHByZXNzS2lsbFNlcnZlciIsImtpbGxTZXJ2ZXIiLCJlcnJvciIsImFkYlBvcnQiLCJhZGJFeGVjIiwiZXhjbHVzaXZlIiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsImRzdFBhdGgiLCJ3cml0ZUZpbGUiLCJhZGJFeGVjRW11IiwiY21kIiwidmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQiLCJpc0V4ZWNMb2NrZWQiLCJvcHRzIiwiY2xvbmVEZWVwIiwidGltZW91dCIsImFkYkV4ZWNUaW1lb3V0IiwiREVGQVVMVF9BREJfRVhFQ19USU1FT1VUIiwidGltZW91dENhcE5hbWUiLCJpc0FycmF5IiwiYWRiUmV0cmllZCIsImV4ZWNGdW5jIiwiYXJncyIsInJlcGxhY2UiLCJlcnJUZXh0Iiwic3RkZXJyIiwicHJvdG9jb2xGYXVsdEVycm9yIiwidGVzdCIsImRldmljZU5vdEZvdW5kRXJyb3IiLCJkZXZpY2VDb25uZWN0aW5nRXJyb3IiLCJjb2RlIiwid2FpdE1zIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImludGVydmFsTXMiLCJzaGVsbCIsInByaXZpbGVnZWQiLCJrZWVwUHJpdmlsZWdlZCIsInNob3VsZFJlc3RvcmVVc2VyIiwid2FzQWxyZWFkeVJvb3RlZCIsImlzU3VjY2Vzc2Z1bCIsInJvb3QiLCJkaWRDb21tYW5kRmFpbCIsImVyciIsInVucm9vdCIsImNyZWF0ZVN1YlByb2Nlc3MiLCJjb25jYXQiLCJTdWJQcm9jZXNzIiwiZ2V0QWRiUGF0aCIsImdldEFkYlNlcnZlclBvcnQiLCJnZXRFbXVsYXRvclBvcnQiLCJlbXVsYXRvclBvcnQiLCJwb3J0IiwiZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyIsImVtU3RyIiwicG9ydFBhdHRlcm4iLCJwYXJzZUludCIsImV4ZWMiLCJnZXRDb25uZWN0ZWRFbXVsYXRvcnMiLCJlbXVsYXRvcnMiLCJkZXZpY2UiLCJzZXRFbXVsYXRvclBvcnQiLCJlbVBvcnQiLCJzZXREZXZpY2VJZCIsImRldmljZUlkIiwiY3VyRGV2aWNlSWQiLCJhcmdzSGFzRGV2aWNlIiwic3BsaWNlIiwic2V0RGV2aWNlIiwiZGV2aWNlT2JqIiwiZ2V0UnVubmluZ0FWRCIsImF2ZE5hbWUiLCJlbXVsYXRvciIsInJ1bm5pbmdBVkROYW1lIiwic2VuZFRlbG5ldENvbW1hbmQiLCJ0b0xvd2VyIiwiZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSIsInJ1bm5pbmdBdmQiLCJraWxsQWxsRW11bGF0b3JzIiwia2lsbEVtdWxhdG9yIiwidXRpbCIsImhhc1ZhbHVlIiwiaXNFbXVsYXRvckNvbm5lY3RlZCIsImlnbiIsImxhdW5jaEFWRCIsImF2ZEFyZ3MiLCJsYW5ndWFnZSIsImNvdW50cnkiLCJhdmRMYXVuY2hUaW1lb3V0IiwiYXZkUmVhZHlUaW1lb3V0IiwicmV0cnlUaW1lcyIsImVtdWxhdG9yQmluYXJ5UGF0aCIsInN1YnN0ciIsImNoZWNrQXZkRXhpc3QiLCJsYXVuY2hBcmdzIiwiaXNTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwibG9jYWxlIiwicHJvYyIsIm9uIiwiQm9vbGVhbiIsInNpZ25hbCIsIndhaXRGb3JFbXVsYXRvclJlYWR5IiwiZ2V0QWRiVmVyc2lvbiIsImFkYlZlcnNpb24iLCJwYXJ0cyIsInZlcnNpb25TdHJpbmciLCJ2ZXJzaW9uRmxvYXQiLCJwYXJzZUZsb2F0IiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidW5rbm93bk9wdGlvbkVycm9yIiwic2RrVmVyc2lvbiIsImV4aXN0aW5ncyIsIndhaXRGb3JEZXZpY2UiLCJhcHBEZXZpY2VSZWFkeVRpbWVvdXQiLCJyZXRyaWVzIiwicGluZyIsInJlYm9vdCIsIkIiLCJkZWxheSIsInNldERldmljZVByb3BlcnR5Iiwic3RhcnRlZCIsImhydGltZSIsImdldERldmljZVByb3BlcnR5IiwibXNnIiwiY2hhbmdlVXNlclByaXZpbGVnZXMiLCJpc0VsZXZhdGVkIiwiaXNSb290IiwiZmlsZUV4aXN0cyIsInJlbW90ZVBhdGgiLCJmaWxlcyIsImxzIiwibGluZXMiLCJsIiwiZmlsZVNpemUiLCJtYXRjaCIsImlzTmFOIiwiaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSIsImNlcnQiLCJvcGVuU3NsIiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwidG1wUm9vdCIsInRlbXBEaXIiLCJvcGVuRGlyIiwic3JjQ2VydCIsImNlcnRIYXNoIiwiZHN0Q2VydENvbnRlbnQiLCJkc3RDZXJ0IiwicmltcmFmIiwiaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQiLCJ0bXBDZXJ0IiwicG9zaXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0EsSUFBSUEsaUJBQWlCLEdBQUcsRUFBeEI7QUFFQSxNQUFNQywwQkFBMEIsR0FBRyxFQUFuQztBQUVBLE1BQU1DLHFCQUFxQixHQUFHLHNCQUE5QjtBQUNBLE1BQU1DLDJCQUEyQixHQUFHLElBQUlDLE1BQUosQ0FBVyxnQ0FBWCxFQUE2QyxHQUE3QyxDQUFwQztBQUNBLE1BQU1DLDZCQUE2QixHQUFHLElBQUlELE1BQUosQ0FBWSxpQ0FBWixFQUE4QyxHQUE5QyxDQUF0QztBQUNBLE1BQU1FLDhCQUE4QixHQUFHLElBQUlGLE1BQUosQ0FBVyxnQ0FBWCxFQUE2QyxHQUE3QyxDQUF2QztBQUVBLE1BQU1HLFVBQVUsR0FBRyw4QkFBbkI7O0FBUUFQLGlCQUFpQixDQUFDUSxnQkFBbEIsR0FBcUMsZUFBZUEsZ0JBQWYsQ0FBaUNDLFVBQWpDLEVBQTZDO0FBQ2hGLE1BQUksS0FBS0MsT0FBVCxFQUFrQjtBQUNoQixXQUFPLE1BQU0sS0FBS0Msb0JBQUwsQ0FBMEJGLFVBQTFCLENBQWI7QUFDRDs7QUFDREcsa0JBQUlDLElBQUos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LE1BQUk7QUFDRixVQUFNSyxPQUFPLEdBQUd4TixjQUFLUSxPQUFMLENBQWF1TSxPQUFiLEVBQXNCLFlBQXRCLENBQWhCOztBQUNBLFVBQU01TCxrQkFBR2dELFNBQUgsQ0FBYXFKLE9BQWIsRUFBc0JkLElBQXRCLENBQU47QUFDQSxVQUFNO0FBQUM3SyxNQUFBQTtBQUFELFFBQVcsTUFBTSx3QkFBSzhLLE9BQUwsRUFBYyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLEVBQW1DYSxPQUFuQyxDQUFkLENBQXZCO0FBQ0FMLElBQUFBLFFBQVEsR0FBR3RMLE1BQU0sQ0FBQ1csSUFBUCxFQUFYO0FBQ0QsR0FMRCxDQUtFLE9BQU84RCxHQUFQLEVBQVk7QUFDWixVQUFNLElBQUloRixLQUFKLENBQVcsd0NBQUQsR0FDQywwREFERCxHQUVDLG1CQUFrQmdGLEdBQUcsQ0FBQ3RFLE9BQVEsRUFGekMsQ0FBTjtBQUdELEdBVEQsU0FTVTtBQUNSLFVBQU1iLGtCQUFHbU0sTUFBSCxDQUFVUCxPQUFWLENBQU47QUFDRDs7QUFDRCxRQUFNN0ksT0FBTyxHQUFHbEUsY0FBS3lOLEtBQUwsQ0FBV2pOLE9BQVgsQ0FBbUJ0QixVQUFuQixFQUFnQyxHQUFFaU8sUUFBUyxJQUEzQyxDQUFoQjs7QUFDQTVOLGtCQUFJcUMsS0FBSixDQUFXLHdEQUF1RHNDLE9BQVEsR0FBMUU7O0FBQ0EsU0FBTyxNQUFNLEtBQUs4SCxVQUFMLENBQWdCOUgsT0FBaEIsQ0FBYjtBQUNELENBeEJEOztlQTBCZXZGLGlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCB1dGlsLCB0ZW1wRGlyIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHtcbiAgZ2V0U2RrVG9vbHNWZXJzaW9uLFxuICBnZXRCdWlsZFRvb2xzRGlycyxcbiAgZ2V0T3BlblNzbEZvck9zLFxuICBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQgfSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuXG5cbmxldCBzeXN0ZW1DYWxsTWV0aG9kcyA9IHt9O1xuXG5jb25zdCBERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyA9IDkwO1xuXG5jb25zdCBMSU5LRVJfV0FSTklOR19SRUdFWFAgPSAvXldBUk5JTkc6IGxpbmtlci4rJC9tO1xuY29uc3QgUFJPVE9DT0xfRkFVTFRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgncHJvdG9jb2wgZmF1bHQgXFxcXChubyBzdGF0dXNcXFxcKScsICdpJyk7XG5jb25zdCBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoYGVycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmRgLCAnaScpO1xuY29uc3QgREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgnZXJyb3I6IGRldmljZSBzdGlsbCBjb25uZWN0aW5nJywgJ2knKTtcblxuY29uc3QgQ0VSVFNfUk9PVCA9ICcvc3lzdGVtL2V0Yy9zZWN1cml0eS9jYWNlcnRzJztcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gYXN5bmMgZnVuY3Rpb24gZ2V0U2RrQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICBpZiAodGhpcy5zZGtSb290KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QoYmluYXJ5TmFtZSk7XG4gIH1cbiAgbG9nLndhcm4oYFRoZSBBTkRST0lEX0hPTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCB0byB0aGUgQW5kcm9pZCBTREsgYCArXG4gICAgYHJvb3QgZGlyZWN0b3J5IHBhdGguIEFORFJPSURfSE9NRSBpcyByZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSBgICtcbiAgICBgd2l0aCBTREsgMjMrLiBDaGVja2luZyBhbG9uZyBQQVRIIGZvciAke2JpbmFyeU5hbWV9LmApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tUGF0aChiaW5hcnlOYW1lKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZUZvck9TIChiaW5hcnlOYW1lKSB7XG4gIGlmICghc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgcmV0dXJuIGJpbmFyeU5hbWU7XG4gIH1cblxuICBpZiAoWydhbmRyb2lkJywgJ2Fwa3NpZ25lcicsICdhcGthbmFseXplciddLmluY2x1ZGVzKGJpbmFyeU5hbWUpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmJhdGA7XG4gIH1cbiAgaWYgKCFwYXRoLmV4dG5hbWUoYmluYXJ5TmFtZSkpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGFuZCBjYWNoZXMgaXQgaW50byBgYmluYXJpZXNgXG4gKiBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBBREIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBTaW1wbGUgbmFtZSBvZiBhIGJpbmFyeSBmaWxlLlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS4gVGhlIG1ldGhvZCB0cmllc1xuICogICAgICAgICAgICAgICAgICB0byBlbnVtZXJhdGUgYWxsIHRoZSBrbm93biBsb2NhdGlvbnMgd2hlcmUgdGhlIGJpbmFyeVxuICogICAgICAgICAgICAgICAgICBtaWdodCBiZSBsb2NhdGVkIGFuZCBzdG9wcyB0aGUgc2VhcmNoIGFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgIG1hdGNoIGlzIGZvdW5kIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYmluYXJ5IHdpdGggZ2l2ZW4gbmFtZSBpcyBub3QgcHJlc2VudCBhdCBhbnlcbiAqICAgICAgICAgICAgICAgICBvZiBrbm93biBsb2NhdGlvbnMgb3IgQW5kcm9pZCBTREsgaXMgbm90IGluc3RhbGxlZCBvbiB0aGVcbiAqICAgICAgICAgICAgICAgICBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QgPSBhc3luYyBmdW5jdGlvbiBnZXRCaW5hcnlGcm9tU2RrUm9vdCAoYmluYXJ5TmFtZSkge1xuICBpZiAodGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSkge1xuICAgIHJldHVybiB0aGlzLmJpbmFyaWVzW2JpbmFyeU5hbWVdO1xuICB9XG5cbiAgY29uc3QgZnVsbEJpbmFyeU5hbWUgPSB0aGlzLmdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbiAgY29uc3QgYmluYXJ5TG9jcyA9IFsncGxhdGZvcm0tdG9vbHMnLCAnZW11bGF0b3InLCAndG9vbHMnLCBgdG9vbHMke3BhdGguc2VwfWJpbmBdXG4gICAgLm1hcCgoeCkgPT4gcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgeCwgZnVsbEJpbmFyeU5hbWUpKTtcbiAgLy8gZ2V0IHN1YnBhdGhzIGZvciBjdXJyZW50bHkgaW5zdGFsbGVkIGJ1aWxkIHRvb2wgZGlyZWN0b3JpZXNcbiAgbGV0IGJ1aWxkVG9vbHNEaXJzID0gYXdhaXQgZ2V0QnVpbGRUb29sc0RpcnModGhpcy5zZGtSb290KTtcbiAgaWYgKHRoaXMuYnVpbGRUb29sc1ZlcnNpb24pIHtcbiAgICBidWlsZFRvb2xzRGlycyA9IGJ1aWxkVG9vbHNEaXJzXG4gICAgICAuZmlsdGVyKCh4KSA9PiBwYXRoLmJhc2VuYW1lKHgpID09PSB0aGlzLmJ1aWxkVG9vbHNWZXJzaW9uKTtcbiAgICBpZiAoXy5pc0VtcHR5KGJ1aWxkVG9vbHNEaXJzKSkge1xuICAgICAgbG9nLmluZm8oYEZvdW5kIG5vIGJ1aWxkIHRvb2xzIHdob3NlIHZlcnNpb24gbWF0Y2hlcyB0byAnJHt0aGlzLmJ1aWxkVG9vbHNWZXJzaW9ufSdgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oYFVzaW5nIGJ1aWxkIHRvb2xzIGF0ICcke2J1aWxkVG9vbHNEaXJzfSdgKTtcbiAgICB9XG4gIH1cbiAgYmluYXJ5TG9jcy5wdXNoKC4uLihidWlsZFRvb2xzRGlycy5tYXAoKGRpcikgPT4gcGF0aC5yZXNvbHZlKGRpciwgZnVsbEJpbmFyeU5hbWUpKSkpO1xuXG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBmb3IgKGNvbnN0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICBiaW5hcnlMb2MgPSBsb2M7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKF8uaXNOdWxsKGJpbmFyeUxvYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICcke2Z1bGxCaW5hcnlOYW1lfScgaW4gJHtKU09OLnN0cmluZ2lmeShiaW5hcnlMb2NzKX0uIGAgK1xuICAgICAgYERvIHlvdSBoYXZlIEFuZHJvaWQgQnVpbGQgVG9vbHMgJHt0aGlzLmJ1aWxkVG9vbHNWZXJzaW9uID8gYHYgJHt0aGlzLmJ1aWxkVG9vbHNWZXJzaW9ufSBgIDogJyd9YCArXG4gICAgICBgaW5zdGFsbGVkIGF0ICcke3RoaXMuc2RrUm9vdH0nP2ApO1xuICB9XG4gIGxvZy5pbmZvKGBVc2luZyAnJHtmdWxsQmluYXJ5TmFtZX0nIGZyb20gJyR7YmluYXJ5TG9jfSdgKTtcbiAgdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSA9IGJpbmFyeUxvYztcbiAgcmV0dXJuIGJpbmFyeUxvYztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldEJpbmFyeUZyb21QYXRoIChiaW5hcnlOYW1lKSB7XG4gIGlmICh0aGlzLmJpbmFyaWVzW2JpbmFyeU5hbWVdKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV07XG4gIH1cblxuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IGJpbmFyeUxvYyA9IGF3YWl0IGZzLndoaWNoKGZ1bGxCaW5hcnlOYW1lKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJyR7ZnVsbEJpbmFyeU5hbWV9JyBmcm9tICcke2JpbmFyeUxvY30nYCk7XG4gICAgdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSA9IGJpbmFyeUxvYztcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAnJHtmdWxsQmluYXJ5TmFtZX0nIGluIFBBVEguIFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgIGBvciBBTkRST0lEX1NES19ST09UIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgY29ycmVjdCBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBkZXZpY2VzIG9yIGFuIGVtcHR5IGxpc3QgaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBubyBkZXZpY2VzIGFyZSBjb25uZWN0ZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGxpc3RpbmcgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRGV2aWNlcyA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZERldmljZXMgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgY29ubmVjdGVkIGRldmljZXMuLi4nKTtcbiAgbGV0IHN0ZG91dDtcbiAgdHJ5IHtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAnZGV2aWNlcyddKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGdldHRpbmcgY29ubmVjdGVkIGRldmljZXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICBjb25zdCBsaXN0SGVhZGVyID0gJ0xpc3Qgb2YgZGV2aWNlcyc7XG4gIC8vIGV4cGVjdGluZyBhZGIgZGV2aWNlcyB0byByZXR1cm4gb3V0cHV0IGFzXG4gIC8vIExpc3Qgb2YgZGV2aWNlcyBhdHRhY2hlZFxuICAvLyBlbXVsYXRvci01NTU0XHRkZXZpY2VcbiAgY29uc3Qgc3RhcnRpbmdJbmRleCA9IHN0ZG91dC5pbmRleE9mKGxpc3RIZWFkZXIpO1xuICBpZiAoc3RhcnRpbmdJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IHdoaWxlIHRyeWluZyB0byBnZXQgZGV2aWNlczogJHtzdGRvdXR9YCk7XG4gIH1cbiAgLy8gc2xpY2luZyBvdXRwdXQgd2UgY2FyZSBhYm91dFxuICBzdGRvdXQgPSBzdGRvdXQuc2xpY2Uoc3RhcnRpbmdJbmRleCk7XG4gIGNvbnN0IGV4Y2x1ZGVkTGluZXMgPSBbbGlzdEhlYWRlciwgJ2FkYiBzZXJ2ZXInLCAnKiBkYWVtb24nLCAnb2ZmbGluZSddO1xuICBjb25zdCBkZXZpY2VzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKVxuICAgIC5tYXAoXy50cmltKVxuICAgIC5maWx0ZXIoKGxpbmUpID0+IGxpbmUgJiYgIWV4Y2x1ZGVkTGluZXMuc29tZSgoeCkgPT4gbGluZS5pbmNsdWRlcyh4KSkpXG4gICAgLnJlZHVjZSgoYWNjLCBsaW5lKSA9PiB7XG4gICAgICAvLyBzdGF0ZSBpcyBcImRldmljZVwiLCBhZmFpY1xuICAgICAgY29uc3QgW3VkaWQsIHN0YXRlXSA9IGxpbmUuc3BsaXQoL1xccysvKTtcbiAgICAgIGFjYy5wdXNoKHt1ZGlkLCBzdGF0ZX0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG4gIGlmIChfLmlzRW1wdHkoZGV2aWNlcykpIHtcbiAgICBsb2cuZGVidWcoJ05vIGNvbm5lY3RlZCBkZXZpY2VzIGhhdmUgYmVlbiBkZXRlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIGxvZy5kZWJ1ZyhgQ29ubmVjdGVkIGRldmljZXM6ICR7SlNPTi5zdHJpbmdpZnkoZGV2aWNlcyl9YCk7XG4gIH1cbiAgcmV0dXJuIGRldmljZXM7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGdldCBhdCBsZWFzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZSBsaXN0IGl0ZW0uXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gY29ubmVjdGVkIGRldmljZXMgY2FuIGJlIGRldGVjdGVkIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RGV2aWNlc1dpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIGdldERldmljZXNXaXRoUmV0cnkgKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZygnVHJ5aW5nIHRvIGZpbmQgYSBjb25uZWN0ZWQgYW5kcm9pZCBkZXZpY2UnKTtcbiAgbGV0IGdldERldmljZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChEYXRlLm5vdygpIC0gc3RhcnQpID4gdGltZW91dE1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlLicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgbG9nLmRlYnVnKCdDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKCdDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi4nKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgLy8gY29vbCBkb3duXG4gICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG59O1xuXG4vKipcbiAqIFJlc3RhcnQgYWRiIHNlcnZlciwgdW5sZXNzIF90aGlzLnN1cHByZXNzS2lsbFNlcnZlcl8gcHJvcGVydHkgaXMgdHJ1ZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVzdGFydEFkYiA9IGFzeW5jIGZ1bmN0aW9uIHJlc3RhcnRBZGIgKCkge1xuICBpZiAodGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXIpIHtcbiAgICBsb2cuZGVidWcoYE5vdCByZXN0YXJ0aW5nIGFiZCBzaW5jZSAnc3VwcHJlc3NLaWxsU2VydmVyJyBpcyBvbmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZygnUmVzdGFydGluZyBhZGInKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmtpbGxTZXJ2ZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihgRXJyb3Iga2lsbGluZyBBREIgc2VydmVyLCBnb2luZyB0byBzZWUgaWYgaXQncyBvbmxpbmUgYW55d2F5YCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBhZGIgc2VydmVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsU2VydmVyID0gYXN5bmMgZnVuY3Rpb24ga2lsbFNlcnZlciAoKSB7XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBhZGIgc2VydmVyIG9uIHBvcnQgJHt0aGlzLmFkYlBvcnR9YCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2tpbGwtc2VydmVyJ10sIHtcbiAgICBleGNsdXNpdmU6IHRydWUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXNldCBUZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAc2VlIHtAbGluayBodHRwOi8vdG9vbHMuYW5kcm9pZC5jb20vcmVjZW50L2VtdWxhdG9yMjUxNnJlbGVhc2Vub3Rlc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdG9rZW4gcmVzZXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIHJlc2V0VGVsbmV0QXV0aFRva2VuICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy9cbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShob21lRm9sZGVyUGF0aCwgJy5lbXVsYXRvcl9jb25zb2xlX2F1dGhfdG9rZW4nKTtcbiAgbG9nLmRlYnVnKGBPdmVycmlkaW5nICR7ZHN0UGF0aH0gd2l0aCBhbiBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIGZvciBlbXVsYXRvciBjb21tYW5kc2ApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cud2FybihgRXJyb3IgJHtlLm1lc3NhZ2V9IHdoaWxlIHJlc2V0dGluZyB0aGUgY29udGVudCBvZiAke2RzdFBhdGh9LiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBlbXVsYXRvciBjb21tYW5kIHVzaW5nIF9hZGIgZW11XyB0b29sLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjRW11ID0gYXN5bmMgZnVuY3Rpb24gYWRiRXhlY0VtdSAoY21kKSB7XG4gIGF3YWl0IHRoaXMudmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAuLi5jbWRdKTtcbn07XG5cbmxldCBpc0V4ZWNMb2NrZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBhbHNvIHNldCB0aGUgYWRkaXRpb25hbCBgZXhjbHVzaXZlYCBwYXJhbVxuICogICAgICAgICAgICAgICAgICAgICAgICB0byBgdHJ1ZWAgdGhhdCBhc3N1cmVzIG5vIG90aGVyIHBhcmFsbGVsIGFkYiBjb21tYW5kc1xuICogICAgICAgICAgICAgICAgICAgICAgICBhcmUgZ29pbmcgdG8gYmUgZXhlY3V0ZWQgd2hpbGUgdGhlIGN1cnJlbnQgb25lIGlzIHJ1bm5pbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGFkYkV4ZWMgKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKCknKTtcbiAgfVxuXG4gIG9wdHMgPSBfLmNsb25lRGVlcChvcHRzKTtcbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmFkYkV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVDtcbiAgb3B0cy50aW1lb3V0Q2FwTmFtZSA9IG9wdHMudGltZW91dENhcE5hbWUgfHwgJ2FkYkV4ZWNUaW1lb3V0JzsgLy8gRm9yIGVycm9yIG1lc3NhZ2VcblxuICBjbWQgPSBfLmlzQXJyYXkoY21kKSA/IGNtZCA6IFtjbWRdO1xuICBsZXQgYWRiUmV0cmllZCA9IGZhbHNlO1xuICBjb25zdCBleGVjRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXJncyA9IFsuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsIC4uLmNtZF07XG4gICAgICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7dGhpcy5leGVjdXRhYmxlLnBhdGh9ICR7cXVvdGUoYXJncyl9J2ApO1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncywgb3B0cyk7XG4gICAgICAvLyBzb21ldGltZXMgQURCIHByaW50cyBvdXQgd2VpcmQgc3Rkb3V0IHdhcm5pbmdzIHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpbiBhbnkgb2YgdGhlIHJlc3BvbnNlIGRhdGEsIHNvIGxldCdzIHN0cmlwIGl0IG91dFxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJUZXh0ID0gYCR7ZS5tZXNzYWdlfSwgJHtlLnN0ZG91dH0sICR7ZS5zdGRlcnJ9YDtcbiAgICAgIGNvbnN0IHByb3RvY29sRmF1bHRFcnJvciA9IFBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgY29uc3QgZGV2aWNlTm90Rm91bmRFcnJvciA9IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VDb25uZWN0aW5nRXJyb3IgPSBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGlmIChwcm90b2NvbEZhdWx0RXJyb3IgfHwgZGV2aWNlTm90Rm91bmRFcnJvciB8fCBkZXZpY2VDb25uZWN0aW5nRXJyb3IpIHtcbiAgICAgICAgbG9nLmluZm8oYEVycm9yIHNlbmRpbmcgY29tbWFuZCwgcmVjb25uZWN0aW5nIGRldmljZSBhbmQgcmV0cnlpbmc6ICR7Y21kfWApO1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREZXZpY2VzV2l0aFJldHJ5KCk7XG5cbiAgICAgICAgLy8gdHJ5IGFnYWluIG9uZSB0aW1lXG4gICAgICAgIGlmIChhZGJSZXRyaWVkKSB7XG4gICAgICAgICAgYWRiUmV0cmllZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNGdW5jKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUuY29kZSA9PT0gMCAmJiBlLnN0ZG91dCkge1xuICAgICAgICByZXR1cm4gZS5zdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzTnVsbChlLmNvZGUpKSB7XG4gICAgICAgIGUubWVzc2FnZSA9IGBFcnJvciBleGVjdXRpbmcgYWRiRXhlYy4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nLiBgICtcbiAgICAgICAgICBgVHJ5IHRvIGluY3JlYXNlIHRoZSAke29wdHMudGltZW91dH1tcyBhZGIgZXhlY3V0aW9uIHRpbWVvdXQgcmVwcmVzZW50ZWQgYnkgJyR7b3B0cy50aW1lb3V0Q2FwTmFtZX0nIGNhcGFiaWxpdHlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYDtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIGlmIChpc0V4ZWNMb2NrZWQpIHtcbiAgICBsb2cuZGVidWcoJ1dhaXRpbmcgdW50aWwgdGhlIG90aGVyIGV4Y2x1c2l2ZSBBREIgY29tbWFuZCBpcyBjb21wbGV0ZWQnKTtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKCgpID0+ICFpc0V4ZWNMb2NrZWQsIHtcbiAgICAgIHdhaXRNczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBpbnRlcnZhbE1zOiAxMCxcbiAgICB9KTtcbiAgICBsb2cuZGVidWcoJ0NvbnRpbnVpbmcgd2l0aCB0aGUgY3VycmVudCBBREIgY29tbWFuZCcpO1xuICB9XG4gIGlmIChvcHRzLmV4Y2x1c2l2ZSkge1xuICAgIGlzRXhlY0xvY2tlZCA9IHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXhlY0Z1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob3B0cy5leGNsdXNpdmUpIHtcbiAgICAgIGlzRXhlY0xvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaGVsbEV4ZWNPcHRpb25zXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRpbWVvdXRDYXBOYW1lIFthZGJFeGVjVGltZW91dF0gLSB0aGUgbmFtZSBvZiB0aGUgY29ycmVzcG9uZGluZyBBcHBpdW0ncyB0aW1lb3V0IGNhcGFiaWxpdHlcbiAqICh1c2VkIGluIHRoZSBlcnJvciBtZXNzYWdlcykuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHRpbWVvdXQgW2FkYkV4ZWNUaW1lb3V0XSAtIGNvbW1hbmQgZXhlY3V0aW9uIHRpbWVvdXQuXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBwcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIHJ1biB0aGUgZ2l2ZW4gY29tbWFuZCBhcyByb290LlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0ga2VlcFByaXZpbGVnZWQgW2ZhbHN5XSAtIFdoZXRoZXIgdG8ga2VlcCByb290IG1vZGUgYWZ0ZXIgY29tbWFuZCBleGVjdXRpb24gaXMgY29tcGxldGVkLlxuICpcbiAqIEFsbCBvdGhlciBwcm9wZXJ0aWVzIGFyZSB0aGUgc2FtZSBhcyBmb3IgYGV4ZWNgIGNhbGwgZnJvbSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqIG1vZHVsZVxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gY29tbWFuZCB1c2luZyBfYWRiIHNoZWxsXyBwcmVmaXguXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz58c3RyaW5nfSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycyBvciBhIHNpbmdsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0gez9TaGVsbEV4ZWNPcHRpb25zfSBvcHRzIFt7fV0gLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2hlbGwgPSBhc3luYyBmdW5jdGlvbiBzaGVsbCAoY21kLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHByaXZpbGVnZWQsXG4gICAga2VlcFByaXZpbGVnZWQsXG4gIH0gPSBvcHRzO1xuXG4gIC8vIElmIHRoZSBjb21tYW5kIHJlcXVpcmVzIHByaXZpbGVnZXMsIHJvb3QgdGhpcyBkZXZpY2VcbiAgbGV0IHNob3VsZFJlc3RvcmVVc2VyID0gZmFsc2U7XG4gIGlmIChwcml2aWxlZ2VkKSB7XG4gICAgbG9nLmluZm8oYCdhZGIgc2hlbGwgJHtjbWR9JyByZXF1aXJlcyByb290IGFjY2Vzcy4gQXR0ZW1wdGluZyB0byBnYWluIHJvb3QgYWNjZXNzIG5vdy5gKTtcbiAgICBjb25zdCB7d2FzQWxyZWFkeVJvb3RlZCwgaXNTdWNjZXNzZnVsfSA9IGF3YWl0IHRoaXMucm9vdCgpO1xuICAgIHNob3VsZFJlc3RvcmVVc2VyID0gIXdhc0FscmVhZHlSb290ZWQ7XG4gICAgaWYgKHdhc0FscmVhZHlSb290ZWQpIHtcbiAgICAgIGxvZy5pbmZvKCdEZXZpY2UgYWxyZWFkeSBoYWQgcm9vdCBhY2Nlc3MnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oaXNTdWNjZXNzZnVsID8gJ1Jvb3QgYWNjZXNzIHN1Y2Nlc3NmdWxseSBnYWluZWQnIDogJ0NvdWxkIG5vdCBnYWluIHJvb3QgYWNjZXNzJyk7XG4gICAgfVxuICB9XG4gIGxldCBkaWRDb21tYW5kRmFpbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5hZGJFeGVjKF8uaXNBcnJheShjbWQpID8gWydzaGVsbCcsIC4uLmNtZF0gOiBbJ3NoZWxsJywgY21kXSwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkaWRDb21tYW5kRmFpbCA9IHRydWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFJldHVybiB0aGUgJ3Jvb3QnIHN0YXRlIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSAnc2hlbGwnIHdhcyBjYWxsZWRcbiAgICBpZiAocHJpdmlsZWdlZCAmJiBzaG91bGRSZXN0b3JlVXNlciAmJiAoIWtlZXBQcml2aWxlZ2VkIHx8IGRpZENvbW1hbmRGYWlsKSkge1xuICAgICAgY29uc3Qge2lzU3VjY2Vzc2Z1bH0gPSBhd2FpdCB0aGlzLnVucm9vdCgpO1xuICAgICAgbG9nLmRlYnVnKGlzU3VjY2Vzc2Z1bCA/ICdSZXR1cm5lZCBkZXZpY2UgdG8gdW5yb290ZWQgc3RhdGUnIDogJ0NvdWxkIG5vdCByZXR1cm4gZGV2aWNlIHRvIHVucm9vdGVkIHN0YXRlJyk7XG4gICAgfVxuICB9XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5jcmVhdGVTdWJQcm9jZXNzID0gZnVuY3Rpb24gY3JlYXRlU3ViUHJvY2VzcyAoYXJncyA9IFtdKSB7XG4gIC8vIGFkZCB0aGUgZGVmYXVsdCBhcmd1bWVudHNcbiAgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncyk7XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgQURCIHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5nZXRBZGJQYXRoKCksIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhZGIgcG9ydC5cbiAqIEB0b2RvIGNhbiBwcm9iYWJseSBkZXByZWNhdGUgdGhpcyBub3cgdGhhdCB0aGUgbG9naWMgaXMganVzdCB0byByZWFkIHRoaXMuYWRiUG9ydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBhZGIgcG9ydCBudW1iZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlNlcnZlclBvcnQgPSBmdW5jdGlvbiBnZXRBZGJTZXJ2ZXJQb3J0ICgpIHtcbiAgcmV0dXJuIHRoaXMuYWRiUG9ydDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBmcm9tIF9hZGIgZGV2aXZlc18gb3V0cHV0LlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEVtdWxhdG9yUG9ydCA9IGFzeW5jIGZ1bmN0aW9uIGdldEVtdWxhdG9yUG9ydCAoKSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBydW5uaW5nIGVtdWxhdG9yIHBvcnQnKTtcbiAgaWYgKHRoaXMuZW11bGF0b3JQb3J0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW11bGF0b3JQb3J0O1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VzWzBdLnVkaWQpO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICByZXR1cm4gcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBwb3J0IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGV2aWNlcyBjb25uZWN0ZWQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGJ5IHBhcnNpbmcgZW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVtU3RyIC0gRW11bGF0b3IgbmFtZSBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gRWl0aGVyIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBfZmFsc2VfIGlmIHBvcnQgbnVtYmVyIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgPSBmdW5jdGlvbiBnZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nIChlbVN0cikge1xuICBsZXQgcG9ydFBhdHRlcm4gPSAvZW11bGF0b3ItKFxcZCspLztcbiAgaWYgKHBvcnRQYXR0ZXJuLnRlc3QoZW1TdHIpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBvcnRQYXR0ZXJuLmV4ZWMoZW1TdHIpWzFdLCAxMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIGVtdWxhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZEVtdWxhdG9ycyAoKSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBjb25uZWN0ZWQgZW11bGF0b3JzJyk7XG4gIHRyeSB7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgZW11bGF0b3JzID0gW107XG4gICAgZm9yIChsZXQgZGV2aWNlIG9mIGRldmljZXMpIHtcbiAgICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZS51ZGlkKTtcbiAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgIGRldmljZS5wb3J0ID0gcG9ydDtcbiAgICAgICAgZW11bGF0b3JzLnB1c2goZGV2aWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGAke2VtdWxhdG9ycy5sZW5ndGh9IGVtdWxhdG9yKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBlbXVsYXRvcnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IF9lbXVsYXRvclBvcnRfIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbVBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldEVtdWxhdG9yUG9ydCA9IGZ1bmN0aW9uIHNldEVtdWxhdG9yUG9ydCAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiBzZXREZXZpY2VJZCAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIHNldERldmljZSAoZGV2aWNlT2JqKSB7XG4gIGxldCBkZXZpY2VJZCA9IGRldmljZU9iai51ZGlkO1xuICBsZXQgZW1Qb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZUlkKTtcbiAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW1Qb3J0KTtcbiAgdGhpcy5zZXREZXZpY2VJZChkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHJldHVybiB7P0RldmljZX0gQ3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3Igb3IgX251bGxfLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVubmluZ0FWRCAoYXZkTmFtZSkge1xuICBsb2cuZGVidWcoYFRyeWluZyB0byBmaW5kICcke2F2ZE5hbWV9JyBlbXVsYXRvcmApO1xuICB0cnkge1xuICAgIGNvbnN0IGVtdWxhdG9ycyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzKCk7XG4gICAgZm9yIChjb25zdCBlbXVsYXRvciBvZiBlbXVsYXRvcnMpIHtcbiAgICAgIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtdWxhdG9yLnBvcnQpO1xuICAgICAgY29uc3QgcnVubmluZ0FWRE5hbWUgPSBhd2FpdCB0aGlzLnNlbmRUZWxuZXRDb21tYW5kKCdhdmQgbmFtZScpO1xuICAgICAgaWYgKF8udG9Mb3dlcihhdmROYW1lKSA9PT0gXy50b0xvd2VyKHJ1bm5pbmdBVkROYW1lKSkge1xuICAgICAgICBsb2cuZGVidWcoYEZvdW5kIGVtdWxhdG9yICcke2F2ZE5hbWV9JyBvbiBwb3J0ICR7ZW11bGF0b3IucG9ydH1gKTtcbiAgICAgICAgdGhpcy5zZXREZXZpY2VJZChlbXVsYXRvci51ZGlkKTtcbiAgICAgICAgcmV0dXJuIGVtdWxhdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYEVtdWxhdG9yICcke2F2ZE5hbWV9JyBub3QgcnVubmluZ2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCB1bnRpbCBhdCBsZWFzdCBvbmUgcnVubmluZyBBVkQgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBkZXRlY3RlZC5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBkZXZpY2UgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIHRoZSB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSAoYXZkTmFtZSwgdGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHJ1bm5pbmdBdmQ7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5uaW5nQXZkID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUucmVwbGFjZSgnQCcsICcnKSk7XG4gICAgICAgIHJldHVybiBydW5uaW5nQXZkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZGVidWcoZS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMTAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQgd2l0aCByZXRyeS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBydW5uaW5nQXZkO1xufTtcblxuLyoqXG4gKiBTaHV0ZG93biBhbGwgcnVubmluZyBlbXVsYXRvcnMgYnkga2lsbGluZyB0aGVpciBwcm9jZXNzZXMuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGtpbGxpbmcgdG9vbCByZXR1cm5lZCBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEFsbEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxBbGxFbXVsYXRvcnMgKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgZW11bGF0b3Igd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gTm8gZXJyb3JcbiAqIGlzIHRocm93biBpcyBnaXZlbiBhdmQgZG9lcyBub3QgZXhpc3QvaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVtdWxhdG9yIHRvIGJlIGtpbGxlZC4gSWYgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBlbXVsYXRvciB3aWxsIGJlIGtpbGxlZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4Y2VwdGlvbiBhYm91dCB1bnN1Y2Nlc3NmdWwga2lsbGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbXVsYXRvciB3YXMga2lsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGEgZmFpbHVyZSBieSBraWxsaW5nIHRoZSBlbXVsYXRvclxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiBraWxsRW11bGF0b3IgKGF2ZE5hbWUgPSBudWxsLCB0aW1lb3V0ID0gNjAwMDApIHtcbiAgaWYgKHV0aWwuaGFzVmFsdWUoYXZkTmFtZSkpIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkICcke2F2ZE5hbWV9J2ApO1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKTtcbiAgICBpZiAoIWRldmljZSkge1xuICAgICAgbG9nLmluZm8oYE5vIGF2ZCB3aXRoIG5hbWUgJyR7YXZkTmFtZX0nIHJ1bm5pbmcuIFNraXBwaW5nIGtpbGwgc3RlcC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8ga2lsbGluZyB0aGUgY3VycmVudCBhdmRcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nYCk7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nLmRlYnVnKGBFbXVsYXRvciB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9JyBub3QgY29ubmVjdGVkLiBTa2lwcGluZyBraWxsIHN0ZXBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2tpbGwnXSk7XG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3RpbWVvdXR9bXMgdW50aWwgdGhlIGVtdWxhdG9yICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGlzIGtpbGxlZGApO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaGFzVmFsdWUoYXZkTmFtZSlcbiAgICAgICAgICA/ICFhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSlcbiAgICAgICAgICA6ICFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXQsXG4gICAgICBpbnRlcnZhbE1zOiAyMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMgc3RpbGwgcnVubmluZyBhZnRlciBiZWluZyBraWxsZWQgJHt0aW1lb3V0fW1zIGFnb2ApO1xuICB9XG4gIGxvZy5pbmZvKGBTdWNjZXNzZnVsbHkga2lsbGVkIHRoZSAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBlbXVsYXRvcmApO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogU3RhcnQgYW4gZW11bGF0b3Igd2l0aCBnaXZlbiBwYXJhbWV0ZXJzIGFuZCB3YWl0IHVudGlsIGl0IGlzIGZ1bGwgc3RhcnRlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGFuIGV4aXN0aW5nIGVtdWxhdG9yLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IGF2ZEFyZ3MgLSBBZGRpdGlvbmFsIGVtdWxhdG9yIGNvbW1hbmQgbGluZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gbGFuZ3VhZ2UgLSBFbXVsYXRvciBzeXN0ZW0gbGFuZ3VhZ2UuXG4gKiBAcGFyYW0gez9jb3VudHJ5fSBjb3VudHJ5IC0gRW11bGF0b3Igc3lzdGVtIGNvdW50cnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYXZkTGF1bmNoVGltZW91dCBbNjAwMDBdIC0gRW11bGF0b3Igc3RhcnR1cCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeVRpbWVzIFsxXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGFydHVwIHJldHJpZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGZhaWxzIHRvIHN0YXJ0IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gbGF1bmNoQVZEIChhdmROYW1lLCBhdmRBcmdzLCBsYW5ndWFnZSwgY291bnRyeSxcbiAgYXZkTGF1bmNoVGltZW91dCA9IDYwMDAwLCBhdmRSZWFkeVRpbWVvdXQgPSA2MDAwMCwgcmV0cnlUaW1lcyA9IDEpIHtcbiAgbG9nLmRlYnVnKGBMYXVuY2hpbmcgRW11bGF0b3Igd2l0aCBBVkQgJHthdmROYW1lfSwgbGF1bmNoVGltZW91dCBgICtcbiAgICAgICAgICAgIGAke2F2ZExhdW5jaFRpbWVvdXR9bXMgYW5kIHJlYWR5VGltZW91dCAke2F2ZFJlYWR5VGltZW91dH1tc2ApO1xuICBsZXQgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcbiAgbGV0IGxhdW5jaEFyZ3MgPSBbJy1hdmQnLCBhdmROYW1lXTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExhbmd1YWdlIHRvICR7bGFuZ3VhZ2V9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5sYW5ndWFnZT0ke2xhbmd1YWdlLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgQ291bnRyeSB0byAke2NvdW50cnl9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5jb3VudHJ5PSR7Y291bnRyeS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGxldCBsb2NhbGU7XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSAmJiBfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSArICctJyArIGNvdW50cnkudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgIGxvY2FsZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvY2FsZSA9IGNvdW50cnk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcobG9jYWxlKSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMb2NhbGUgdG8gJHtsb2NhbGV9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5sb2NhbGU9JHtsb2NhbGV9YCk7XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkoYXZkQXJncykpIHtcbiAgICBsYXVuY2hBcmdzLnB1c2goLi4uKF8uaXNBcnJheShhdmRBcmdzKSA/IGF2ZEFyZ3MgOiBhdmRBcmdzLnNwbGl0KCcgJykpKTtcbiAgfVxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGxhdW5jaEFyZ3MpfWApO1xuICBsZXQgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncyk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCBzdGRlcnIgfHwgJycpLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbikpIHtcbiAgICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtsaW5lfWApO1xuICAgIH1cbiAgfSk7XG4gIHByb2Mub24oJ2RpZScsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBsb2cud2FybihgRW11bGF0b3IgYXZkICR7YXZkTmFtZX0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9JHtzaWduYWwgPyBgLCBzaWduYWwgJHtzaWduYWx9YCA6ICcnfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5KGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpKTtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShhdmRSZWFkeVRpbWVvdXQpO1xuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQURCVmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb25TdHJpbmcgLSBBREIgdmVyc2lvbiBhcyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHZlcnNpb25GbG9hdCAtIFZlcnNpb24gbnVtYmVyIGFzIGZsb2F0IHZhbHVlICh1c2VmdWwgZm9yIGNvbXBhcmlzb24pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ham9yIC0gTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWlub3IgLSBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXRjaCAtIFBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7QURCVmVyc2lvbn0gVGhlIGN1cnJlbnQgYWRiIHZlcnNpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIGdldEFkYlZlcnNpb24gKCkge1xuICB0cnkge1xuICAgIGxldCBhZGJWZXJzaW9uID0gKGF3YWl0IHRoaXMuYWRiRXhlYygndmVyc2lvbicpKVxuICAgICAgLnJlcGxhY2UoL0FuZHJvaWRcXHNEZWJ1Z1xcc0JyaWRnZVxcc3ZlcnNpb25cXHMoW1xcZC5dKilbXFxzXFx3LV0qLywgJyQxJyk7XG4gICAgbGV0IHBhcnRzID0gYWRiVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uU3RyaW5nOiBhZGJWZXJzaW9uLFxuICAgICAgdmVyc2lvbkZsb2F0OiBwYXJzZUZsb2F0KGFkYlZlcnNpb24pLFxuICAgICAgbWFqb3I6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBtaW5vcjogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHBhdGNoOiBwYXJ0c1syXSA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBhZGIgdmVyc2lvbi4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVtdWxhdG9yIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgYXZkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGVtdWxhdG9yIHRvIHZlcmlmeSBmb3IgZXhpc3RlbmNlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciB3aXRoIGdpdmVuIG5hbWUgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNoZWNrQXZkRXhpc3QgPSBhc3luYyBmdW5jdGlvbiBjaGVja0F2ZEV4aXN0IChhdmROYW1lKSB7XG4gIGxldCBjbWQsIHJlc3VsdDtcbiAgdHJ5IHtcbiAgICBjbWQgPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoJ2VtdWxhdG9yJyk7XG4gICAgcmVzdWx0ID0gYXdhaXQgZXhlYyhjbWQsIFsnLWxpc3QtYXZkcyddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxldCB1bmtub3duT3B0aW9uRXJyb3IgPSBuZXcgUmVnRXhwKCd1bmtub3duIG9wdGlvbjogLWxpc3QtYXZkcycsICdpJykudGVzdChlLnN0ZGVycik7XG4gICAgaWYgKCF1bmtub3duT3B0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhlY3V0aW5nIGNoZWNrQXZkRXhpc3QuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcblxuICAgIH1cbiAgICBjb25zdCBzZGtWZXJzaW9uID0gYXdhaXQgZ2V0U2RrVG9vbHNWZXJzaW9uKCk7XG4gICAgbGV0IGJpbmFyeU5hbWUgPSAnYW5kcm9pZCc7XG4gICAgaWYgKHNka1ZlcnNpb24pIHtcbiAgICAgIGlmIChzZGtWZXJzaW9uLm1ham9yID49IDI1KSB7XG4gICAgICAgIGJpbmFyeU5hbWUgPSAnYXZkbWFuYWdlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBEZWZhdWx0aW5nIGJpbmFyeSBuYW1lIHRvICcke2JpbmFyeU5hbWV9JywgYmVjYXVzZSBTREsgdmVyc2lvbiBjYW5ub3QgYmUgcGFyc2VkYCk7XG4gICAgfVxuICAgIC8vIElmIC1saXN0LWF2ZHMgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUsIHVzZSBhbmRyb2lkIGNvbW1hbmQgYXMgYW4gYWx0ZXJuYXRpdmVcbiAgICBjbWQgPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoYmluYXJ5TmFtZSk7XG4gICAgcmVzdWx0ID0gYXdhaXQgZXhlYyhjbWQsIFsnbGlzdCcsICdhdmQnLCAnLWMnXSk7XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGRvdXQuaW5kZXhPZihhdmROYW1lKSA9PT0gLTEpIHtcbiAgICBsZXQgZXhpc3RpbmdzID0gYCgke3Jlc3VsdC5zdGRvdXQudHJpbSgpLnJlcGxhY2UoL1tcXG5dL2csICcpLCAoJyl9KWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBdmQgJyR7YXZkTmFtZX0nIGlzIG5vdCBhdmFpbGFibGUuIHBsZWFzZSBzZWxlY3QgeW91ciBhdmQgbmFtZSBmcm9tIG9uZSBvZiB0aGVzZTogJyR7ZXhpc3RpbmdzfSdgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBlbXVsYXRvciBpcyByZWFkeSB0byBhY2NlcHQgZnVydGhlciBjb21tYW5kcyAoYm9vdGluZyBjb21wbGV0ZWQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzIwMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckVtdWxhdG9yUmVhZHkgPSBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yRW11bGF0b3JSZWFkeSAodGltZW91dE1zID0gMjAwMDApIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuc2hlbGwoWydnZXRwcm9wJywgJ2luaXQuc3ZjLmJvb3RhbmltJ10pKS5pbmNsdWRlcygnc3RvcHBlZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgcGFja2FnZSBtYW5hZ2VyIHNlcnZpY2UgbWlnaHQgc3RpbGwgYmVpbmcgaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gb24gc2xvdyBzeXN0ZW1zIGV2ZW4gYWZ0ZXIgZW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAgICAgIC8vIFRoZSB1c3VhbCBvdXRwdXQgb2YgYHBtIGdldC1pbnN0YWxsLWxvY2F0aW9uYCBjb21tYW5kIGxvb2tzIGxpa2UgYDBbYXV0b11gXG4gICAgICAgIHJldHVybiAvXFxkK1xcW1xcdytcXF0vLnRlc3QoYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2dldC1pbnN0YWxsLWxvY2F0aW9uJ10pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZGVidWcoYFdhaXRpbmcgZm9yIGVtdWxhdG9yIHN0YXJ0dXAuIEludGVybWVkaWF0ZSBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMzAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRW11bGF0b3IgaXMgbm90IHJlYWR5IHdpdGhpbiAke3RpbWVvdXRNc31tc2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGRldmljZSBpcyByZWFkeSB0byBhY2NlcHQgZnVydGhlciBjb21tYW5kcyAoYm9vdGluZyBjb21wbGV0ZWQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQgWzMwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRldmljZSBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRGV2aWNlID0gYXN5bmMgZnVuY3Rpb24gd2FpdEZvckRldmljZSAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHJlYm9vdCAocmV0cmllcyA9IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTKSB7XG4gIC8vIEdldCByb290IGFjY2VzcyBzbyB3ZSBjYW4gcnVuIHRoZSBuZXh0IHNoZWxsIGNvbW1hbmRzIHdoaWNoIHJlcXVpcmUgcm9vdCBhY2Nlc3NcbiAgY29uc3QgeyB3YXNBbHJlYWR5Um9vdGVkIH0gPSBhd2FpdCB0aGlzLnJvb3QoKTtcbiAgdHJ5IHtcbiAgICAvLyBTdG9wIGFuZCByZS1zdGFydCB0aGUgZGV2aWNlXG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSk7XG4gICAgYXdhaXQgQi5kZWxheSgyMDAwKTsgLy8gbGV0IHRoZSBlbXUgZmluaXNoIHN0b3BwaW5nO1xuICAgIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDAsIHtcbiAgICAgIHByaXZpbGVnZWQ6IGZhbHNlIC8vIG5vIG5lZWQgdG8gc2V0IHByaXZpbGVnZWQgdHJ1ZSBiZWNhdXNlIGRldmljZSBhbHJlYWR5IHJvb3RlZFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdGFydCddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IHttZXNzYWdlfSA9IGU7XG5cbiAgICAvLyBwcm92aWRlIGEgaGVscGZ1bCBlcnJvciBtZXNzYWdlIGlmIHRoZSByZWFzb24gcmVib290IGZhaWxlZCB3YXMgYmVjYXVzZSBBREIgY291bGRuJ3QgZ2FpbiByb290IGFjY2Vzc1xuICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdtdXN0IGJlIHJvb3QnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVib290IGRldmljZS4gUmVib290aW5nIHJlcXVpcmVzIHJvb3QgYWNjZXNzIGFuZCBgICtcbiAgICAgICAgYGF0dGVtcHQgdG8gZ2V0IHJvb3QgYWNjZXNzIG9uIGRldmljZSBmYWlsZWQgd2l0aCBlcnJvcjogJyR7bWVzc2FnZX0nYCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmV0dXJuIHJvb3Qgc3RhdGUgdG8gd2hhdCBpdCB3YXMgYmVmb3JlXG4gICAgaWYgKCF3YXNBbHJlYWR5Um9vdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLnVucm9vdCgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKSkgPT09ICcxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICBjb25zdCBtc2cgPSBgUmVib290IGlzIG5vdCBjb21wbGV0ZWQgYWZ0ZXIgJHtwcm9jZXNzLmhydGltZShzdGFydGVkKVswXX1zYDtcbiAgICBsb2cuZGVidWcobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHJvb3RSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdWNjZXNzZnVsIFRydWUgaWYgdGhlIGNhbGwgdG8gcm9vdC91bnJvb3Qgd2FzIHN1Y2Nlc3NmdWxcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gd2FzQWxyZWFkeVJvb3RlZCBUcnVlIGlmIHRoZSBkZXZpY2Ugd2FzIGFscmVhZHkgcm9vdGVkXG4gKi9cblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciByb290IHByaXZpbGVnZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRWxldmF0ZWQgLSBTaG91bGQgd2UgZWxldmF0ZSB0byB0byByb290IG9yIHVucm9vdD8gKGRlZmF1bHQgdHJ1ZSlcbiAqIEByZXR1cm4ge3Jvb3RSZXN1bHR9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNoYW5nZVVzZXJQcml2aWxlZ2VzID0gYXN5bmMgZnVuY3Rpb24gY2hhbmdlVXNlclByaXZpbGVnZXMgKGlzRWxldmF0ZWQpIHtcbiAgY29uc3QgY21kID0gaXNFbGV2YXRlZCA/ICdyb290JyA6ICd1bnJvb3QnO1xuXG4gIC8vIElmIGl0J3MgYWxyZWFkeSByb290ZWQsIG91ciBqb2IgaXMgZG9uZS4gTm8gbmVlZCB0byByb290IGl0IGFnYWluLlxuICBjb25zdCBpc1Jvb3QgPSBhd2FpdCB0aGlzLmlzUm9vdCgpO1xuICBpZiAoKGlzUm9vdCAmJiBpc0VsZXZhdGVkKSB8fCAoIWlzUm9vdCAmJiAhaXNFbGV2YXRlZCkpIHtcbiAgICByZXR1cm4ge2lzU3VjY2Vzc2Z1bDogdHJ1ZSwgd2FzQWxyZWFkeVJvb3RlZDogaXNSb290fTtcbiAgfVxuXG4gIGxldCB3YXNBbHJlYWR5Um9vdGVkID0gaXNSb290O1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IHRoaXMuYWRiRXhlYyhbY21kXSk7XG5cbiAgICAvLyBvbiByZWFsIGRldmljZXMgaW4gc29tZSBzaXR1YXRpb25zIHdlIGdldCBhbiBlcnJvciBpbiB0aGUgc3Rkb3V0XG4gICAgaWYgKHN0ZG91dCkge1xuICAgICAgaWYgKHN0ZG91dC5pbmNsdWRlcygnYWRiZCBjYW5ub3QgcnVuIGFzIHJvb3QnKSkge1xuICAgICAgICByZXR1cm4ge2lzU3VjY2Vzc2Z1bDogZmFsc2UsIHdhc0FscmVhZHlSb290ZWR9O1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIGRldmljZSB3YXMgYWxyZWFkeSByb290ZWQsIHJldHVybiB0aGF0IGluIHRoZSByZXN1bHRcbiAgICAgIGlmIChzdGRvdXQuaW5jbHVkZXMoJ2FscmVhZHkgcnVubmluZyBhcyByb290JykpIHtcbiAgICAgICAgd2FzQWxyZWFkeVJvb3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiB0cnVlLCB3YXNBbHJlYWR5Um9vdGVkfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3Qge3N0ZGVyciA9ICcnLCBtZXNzYWdlfSA9IGVycjtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvICR7Y21kfSBhZGIgZGFlbW9uLiBPcmlnaW5hbCBlcnJvcjogJyR7bWVzc2FnZX0nLiBTdGRlcnI6ICcke3N0ZGVycn0nLiBDb250aW51aW5nLmApO1xuXG4gICAgLy8gQ2hlY2sgdGhlIG91dHB1dCBvZiB0aGUgc3RkRXJyIHRvIHNlZSBpZiB0aGVyZSdzIGFueSBjbHVlcyB0aGF0IHNob3cgdGhhdCB0aGUgZGV2aWNlIHdlbnQgb2ZmbGluZVxuICAgIC8vIGFuZCBpZiBpdCBkaWQgZ28gb2ZmbGluZSwgcmVzdGFydCBBREJcbiAgICBpZiAoWydjbG9zZWQnLCAnZGV2aWNlIG9mZmxpbmUnLCAndGltZW91dCBleHBpcmVkJ10uc29tZSgoeCkgPT4gc3RkZXJyLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoeCkpKSB7XG4gICAgICBsb2cud2FybihgQXR0ZW1wdCB0byAnYWRiICR7Y21kfScgY2F1c2VkIGRldmljZSB0byBnbyBvZmZsaW5lLiBSZXN0YXJ0aW5nIGFkYi5gKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgIH1cblxuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiBmYWxzZSwgd2FzQWxyZWFkeVJvb3RlZH07XG4gIH1cbn07XG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgdG8gcm9vdCBtb2RlXG4gKiBAcmV0dXJuIHtyb290UmVzdWx0fVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gcm9vdCAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoYW5nZVVzZXJQcml2aWxlZ2VzKHRydWUpO1xufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge3Jvb3RSZXN1bHR9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHVucm9vdCAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoYW5nZVVzZXJQcml2aWxlZ2VzKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlciBpcyByb290XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyByb290XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGlkZW50aWZ5aW5nXG4gKiB0aGUgdXNlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNSb290ID0gYXN5bmMgZnVuY3Rpb24gaXNSb290ICgpIHtcbiAgcmV0dXJuIChhd2FpdCB0aGlzLnNoZWxsKFsnd2hvYW1pJ10pKS50cmltKCkgPT09ICdyb290Jztcbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSByZW1vdGUgcGF0aCBleGlzdHMgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHZlcmlmeS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzIChyZW1vdGVQYXRoKSB7XG4gIGxldCBmaWxlcyA9IGF3YWl0IHRoaXMubHMocmVtb3RlUGF0aCk7XG4gIHJldHVybiBmaWxlcy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG91dHB1dCBvZiBfbHNfIGNvbW1hbmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoICh0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIF9sc18gY29tbWFuZCkuXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBvcHRzIFtbXV0gLSBBZGRpdGlvbmFsIF9sc18gb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgX2xzXyBvdXRwdXQgYXMgYW4gYXJyYXkgb2Ygc3BsaXQgbGluZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgb2YgdGhlIGdpdmVuIF9yZW1vdGVQYXRoX1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGRvZXMgbm90IGV4aXN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5scyA9IGFzeW5jIGZ1bmN0aW9uIGxzIChyZW1vdGVQYXRoLCBvcHRzID0gW10pIHtcbiAgdHJ5IHtcbiAgICBsZXQgYXJncyA9IFsnbHMnLCAuLi5vcHRzLCByZW1vdGVQYXRoXTtcbiAgICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChhcmdzKTtcbiAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoKGwpID0+IGwudHJpbSgpKVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLmZpbHRlcigobCkgPT4gbC5pbmRleE9mKCdObyBzdWNoIGZpbGUnKSA9PT0gLTEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScpID09PSAtMSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSBwYXJ0aWN1bGFyIGZpbGUgbG9jYXRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdGhlIGZpbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEZpbGUgc2l6ZSBpbiBieXRlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gZmlsZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZVNpemUgPSBhc3luYyBmdW5jdGlvbiBmaWxlU2l6ZSAocmVtb3RlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoLCBbJy1sYSddKTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbW90ZSBwYXRoIGlzIG5vdCBhIGZpbGVgKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9mT3M0UDQvOFxuICAgIGNvbnN0IG1hdGNoID0gL1tyd3hzU3RUXFwtK117MTB9W1xcc1xcZF0qXFxzW15cXHNdK1xccytbXlxcc10rXFxzKyhcXGQrKS8uZXhlYyhmaWxlc1swXSk7XG4gICAgaWYgKCFtYXRjaCB8fCBfLmlzTmFOKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBzaXplIGZyb20gbGlzdCBvdXRwdXQ6ICcke2ZpbGVzWzBdfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBmaWxlIHNpemUgZm9yICcke3JlbW90ZVBhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnN0YWxscyB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgb24gYSByb290ZWQgcmVhbCBkZXZpY2Ugb3JcbiAqIGFuIGVtdWxhdG9yLiBUaGUgZW11bGF0b3IgbXVzdCBiZSBleGVjdXRlZCB3aXRoIGAtd3JpdGFibGUtc3lzdGVtYFxuICogY29tbWFuZCBsaW5lIG9wdGlvbiBhbmQgYWRiIGRhZW1vbiBzaG91bGQgYmUgcnVubmluZyBpbiByb290XG4gKiBtb2RlIGZvciB0aGlzIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LiBUaGUgbWV0aG9kIGFsc28gcmVxdWlyZXNcbiAqIG9wZW5zc2wgdG9vbCB0byBiZSBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbS5cbiAqIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzEwOTY0XG4gKiBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdG9waWNcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluc3RhbGxpbmcgdGhlIGNlcnRpZmljYXRlXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmluc3RhbGxNaXRtQ2VydGlmaWNhdGUgPSBhc3luYyBmdW5jdGlvbiBpbnN0YWxsTWl0bUNlcnRpZmljYXRlIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICB0cnkge1xuICAgIGNvbnN0IHNyY0NlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ3NvdXJjZS5jZXInKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoc3JjQ2VydCwgY2VydCk7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHNyY0NlcnRdKTtcbiAgICBjb25zdCBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gICAgbG9nLmRlYnVnKGBHb3QgY2VydGlmaWNhdGUgaGFzaDogJHtjZXJ0SGFzaH1gKTtcbiAgICBsb2cuZGVidWcoJ1ByZXBhcmluZyBjZXJ0aWZpY2F0ZSBjb250ZW50Jyk7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLWluJywgc3JjQ2VydF0sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBsZXQgZHN0Q2VydENvbnRlbnQgPSBzdGRvdXQ7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLFxuICAgICAgJy1pbicsIHNyY0NlcnQsXG4gICAgICAnLXRleHQnLFxuICAgICAgJy1maW5nZXJwcmludCcsXG4gICAgICAnLW5vb3V0J10sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBkc3RDZXJ0Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoW2RzdENlcnRDb250ZW50LCBzdGRvdXRdKTtcbiAgICBjb25zdCBkc3RDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsIGAke2NlcnRIYXNofS4wYCk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdENlcnQsIGRzdENlcnRDb250ZW50KTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgL3N5c3RlbSBpbiBydyBtb2RlJyk7XG4gICAgLy8gU29tZXRpbWVzIGVtdWxhdG9yIHJlYm9vdCBpcyBzdGlsbCBub3QgZnVsbHkgZmluaXNoZWQgb24gdGhpcyBzdGFnZSwgc28gcmV0cnlcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDUsIDIwMDAsIGFzeW5jICgpID0+IGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSkpO1xuICAgIGxvZy5kZWJ1ZyhgVXBsb2FkaW5nIHRoZSBnZW5lcmF0ZWQgY2VydGlmaWNhdGUgZnJvbSAnJHtkc3RDZXJ0fScgdG8gJyR7Q0VSVFNfUk9PVH0nYCk7XG4gICAgYXdhaXQgdGhpcy5wdXNoKGRzdENlcnQsIENFUlRTX1JPT1QpO1xuICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyAvc3lzdGVtIHRvIGNvbmZpcm0gY2hhbmdlcycpO1xuICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGluamVjdCB0aGUgY3VzdG9tIGNlcnRpZmljYXRlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSByb290IHBlcm1pc3Npb25zIG9uIHRoZSBkZXZpY2U/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSBnaXZlbiByb290IGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjaGVja2luZyB0aGUgY2VydGlmaWNhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZFxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCA9IGFzeW5jIGZ1bmN0aW9uIGlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgY2VydEhhc2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdG1wQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0bXBDZXJ0LCBjZXJ0KTtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCB0bXBDZXJ0XSk7XG4gICAgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXRyaWV2ZSB0aGUgY2VydGlmaWNhdGUgaGFzaC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnBvc2l4LnJlc29sdmUoQ0VSVFNfUk9PVCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBpZiB0aGUgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgYXQgJyR7ZHN0UGF0aH0nYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmZpbGVFeGlzdHMoZHN0UGF0aCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbmV4cG9ydCB7IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCB9O1xuIl0sImZpbGUiOiJsaWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
